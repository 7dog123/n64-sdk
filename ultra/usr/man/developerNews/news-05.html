<html>
<head>
<title>Developers News 1.5</title>
</head>

<body bgcolor="#FFFFFF">

<hr>
<p align="center">
<font size="6"><strong><IMG src="gif/devnews.gif" height="44" width="453">1.5</strong></font>

</p>
<p align="left">
<b> Nintendo 64 Developers Newsletters will be published periodically,
as needed.  These feature software and hardware system anomalies, which
have been discovered, and their solutions and/or work-arounds.  Development
tips will also be included.</b>
</p>

<hr>

<h2>Reset Processing</h2>

There are two types of reset used in the Nintendo 64.  Cold Reset is 
accomplished by cycling the power OFF and ON, while NMI (non-maskable 
interrupt) Reset is generated by pressing the RESET button.  This document 
describes the processing methods for resetting the system using NMI.

<dl>
<dt><b>Note:</b>  There are actually 3 reset methods which can be used with 
the R4000 Series: cold reset, soft reset and NMI, but soft reset is not 
supported by the Nintendo 64.
</dl>

<h3>Processing Flow During Reset</h3>
The processing flow when the user presses the RESET button is as follows.
<ol>
<li>Press RESET button
<li>Pre-NMI is generated
<li>Pre-NMI processing
<li>NMI generated
<li>CPU goes to reset vector
<li>CPU executes boot program
</ol>

The time from Pre-NMI generation to NMI generation is 0.5 seconds or more.  
That is, if the finger is removed from the RESET button within 0.5 seconds, 
this time duration will be 0.5 seconds.  However, if the button is 
continuously pressed for more than 0.5 seconds, the reset time will continue 
until immediately after the finger is removed (i.e., if the button is 
continuously pressed for 1 second, reset time will be 1 second).

<p>
There is no RESET switch on the current emulation boards, but a pseudo-NMI 
can be generated by executing a RESET program (see <a href="./news-02.html">Nintendo 64 Developer News 1.2</a>, "Tip: Handling Console Reset").

<h3>Precautions</h3>
NMI's are generated by the PIF.  The PIF's job is primarily to perform the 
processing for mechanisms which use a serial interface, such as the 
Controller.  Consequently, in cases where the CPU is constantly monitoring 
the Controller, there are instances in which the PIF will be BUSY and RESET 
generation will be delayed.  This creates no problems as long as Controller 
data are read one time per frame.

<p>
In addition, the NMI wait time on current emulation boards is 0.5 seconds or 
more (around several seconds).

<h3>About Pre-NMI Processing</h3>
If the PIF load is at a normal level, a pre-NMI is generated at the time the 
RESET switch is pressed.  The minimum processing that must be performed at 
the time of the  pre-NMI is comprised of the following 4 items:

<ol type=a>
<li>Stop graphics task
<li>Stop audio task
<li>Don't issue a new PI DMA
<li>Return Yscale value to 1 (execute <a target=top href="../n64man/os/osViSetYScale.html">osViSetYScale</a>(1)), if it has been 
modified
</ol>

In other words, all RCP processing is stopped.  When 64DD is used, it must also
be reset.

<h3>Reasons for Pre-NMI</h3>
An NMI signal is generated in the Nintendo 64 only for the CPU.  No RESET 
signal is input to the RCP.  This is because it is difficult to forcibly 
terminate graphic and sound tasks which are currently being executed without 
giving the user an uneasy feeling.

<p>
Therefore, if processing in the RCP is not terminated after the pre-NMI is 
generated, processing in the RCP will continue to be executed even after a 
RESET.  In the worst case, this will have a detrimental effect on the CPU's 
boot sequence, inevitably causing the CPU to hang up.  In order to avoid this 
situation, it is necessary to terminate any processing being executed in the 
RCP after a pre-NMI has been generated.

<h3>Sample of Pre-NMI Processing</h3>
In the following example, a sample source code "simple" has been partially 
modified.

<p>
Each thread senses the generation of a pre-NMI by means of an OS_EVENT_PRENMI 
message, and the necessary processing is performed.

<p>
<hr>
<b>(a) Stopping GFX tasks</b>
<p>
<pre>
static void gameproc (void *argv)
{
  . . .
  while (1)
  {
    . . .
      switch (msg->gen.type)
      {
        . . .

          if (pendingGFX < 2)
          {
            createGfxTask(&glnfo[drawbuffer]);
            pendingGFX++;
            drawbuffer ^=1; /* switch the drawbuffer */
          }

        . . .

        case (OS_SC_PRE_NMI_MSG): /* stop creation of graphics tasks */
          pendingGFX += 2;
          break;
</pre>

<p>
By not creating any new GFX tasks after the pre-NMI is generated, the drawing 
of new screens can be stopped, and the screen can be interrupted.

<p>
In addition, by making the pre-NMI processing portion as follows:

<p>
<pre>
        case (OS_SC_PRE_NMI_MSG): /* stop creation of graphics tasks */
          pendingGFX += 2;
          osViBlack(TRUE);
          break;
</pre>

<p>
The screen can be deleted (cleared to black) at the same time that the 
pre-NMI is generated, after resetting Yscale value to 1.  Other processing 
is also possible in which the screen is gradually cleared by decreasing the 
brightness of the screen in the step-wise fashion, etc.  All of this screen 
clearing processing is to avoid giving the user an uneasy feeling and, at 
the same time, it is necessary on the system level to stop the execution of 
tasks in the RCP by not creating any new tasks (the pendingGFX +=2 line in 
the above sample corresponds with this).

<p>
<hr>
<b>(b) Stopping audio tasks</b>
<p>
<pre>
static void _amMain (void *arg)
{
  . . .

  while (!done)
  {
    . . .

    switch (msg->gen.type)
    {
      . . .

      case (OS_SC_PRE_NMI_MSG):
      /* what should we really do here? quit? ramp down volume? */
        <a target=top href="../n64man/al/alSeqpStop.html">alSeqpStop</a>(seqp) ;
        <a target=top href="../n64man/al/alSeqpDelete.html">alSeqpDelete</a>(seqp) ;
        done = 1;
        break ;

      . . .
    }
  }

  <a target=top href="../n64man/al/alClose.html">alClose</a>(&_am.g);
}
</pre>

<p>
It is possible to stop sound in the same way as graphics by not performing 
any new processing after generating a pre-NMI.  In the above case, the 
procedure

<blockquote>
<a target=top href="../n64man/al/alSeqpStop.html">alSeqpStop</a> -> <a target=top href="../n64man/al/alSeqpDelete.html">alSeqpDelete</a>
</blockquote>

was used because a standard MIDI sequence player is being used, but if a 
compact MIDI player is being used, sound would be stopped using the procedure

<blockquote>
<a target=top href="../n64man/al/alCSPStop.html">alCSPStop</a> -> <a target=top href="../n64man/al/alCSPDelete.html">alCSPDelete</a>
</blockquote>

while if synthesizer voice is being used by a sound effect, the sound effect 
would be stopped using the procedure

<blockquote>
alStopVoice -> <a target=top href="../n64man/al/alSynDelete.html">alSynDelete</a>
</blockquote>

(however, alSynDelete cannot be implemented at the current time).

<p>
Caution is required when using alSeqpDelete and alCSPDelete, since there is 
a system anomaly in the N64 OS up to revision 2.0e which makes it possible 
that the interrupt would continue to be masked.   Because of this, either 
use patch 1.01, or use OS 2.0g or later, when using these functions.

<p>
Processing is also possible which gradually diminishes the sound in the 
same way as the screen by decreasing the volume in a stepwise fashion.  
However, stop the execution of new audio tasks when the volume reaches 0.


<hr>
&copy; 1999 Nintendo of America Inc.

</body>
</html>