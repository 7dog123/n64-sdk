<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<BASE TARGET="main">
<head>
<title>N64 Programming Manual Chapter 19</title>
</head>
<body bgcolor="#FFFFFF">

<table border=0><tr><td><a target="_top" href="../pro19/index19.1.html"><img border=0 src="../images/previous.gif"></a></td>
<td>&nbsp;</td>
<td><a target="_top" href="../pro19/index19.3.html"><img border=0  src="../images/next.gif"></a></td></tr></table>
<P>

<b><font face="arial" color="#29296b">ADPCM AIFC Format</font></b>

<P>
<font face="arial" size="-1" color="#000000">
The compressed ADPCM file format is based around AIFC. It uses a non-standard compression type and two application-specific chunks that contain the codebook and loop point information. This file is generated by the ADPCM encoding tool from standard AIFC and AIFF sample files, and is used by the Instrument Compiler to generate Bank and Table files.

<P>
As in AIFC, chunks are grouped together in a FORM container chunk:
<pre><font face="courier" size="3">typedef struct { 
	ID ckID;	 /* ‘FORM’ */		
	s32 ckDataSize;
	s32 formType;	 /* ‘AIFC’ */
	Chunk chunks[]
}
</pre></font>

<P>
where ckID is always FORM and formType is AIFC. The standard AIFC chunks, which are essential, are the Common chunk, which contains information about the sound length; and the Sound data chunk.
<pre><font face="courier" size="3">typdef struct {
	u32 ckID;		 /* ‘COMM’ */
	s32 ckDataSize;
	s16 numChannels;
	u32 numSampleFrames;
	s16 sampleSize;
	extended sampleRate;
	u32 compressionType; 	/* ‘VAPC’ */
	pstring compressionName; /* ‘VADPCM ~4:1’ */
}
</pre></font>

<P>
The current format accepts only a single channel. The numSampleFrames field should be set to the number of samples represented by the compressed data, not the the number of bytes used. The sampleRate is an 80 bit floating point number (see AIFC spec).

<P>
The Sound data chunk contains the compressed data:
<pre><font face="courier" size="3">typedef struct { 
	u32 ckID;		 /* ‘SSND’ */
	s32 ckDataSize;
	u32 offset;
	u32 blockSize
	u8 soundData[];
}
</pre></font>


<P>
Both <font face="courier" size="-1">offset</font> and <font face="courier" size="-1">blockSize</font> are set to zero.

<P> 
The encoded file will include two application-specific chunks. The common Application Specific data chunk format in AIFC is:
<pre><font face="courier" size="3">typedef struct { 
	u32 ckID;		 /* ‘APPL’ */
	s32 ckDataSize;
	u32 applicationSignature; /* ‘stoc’ */
	u8 data[];
}
</pre></font>

<p>
where <font face="courier" size="-1">data[]</font> contains the application-specific data. 
<P>
The Codebook application-specific data defines a set of predictors that are used in the decoding of the compressed ADPCM data.
<pre><font face="courier" size="3">typedef struct { 
	u16 version;	 /* Should be 01 */
	s16 order;
	u16 nEntries; /* ‘stoc’ */
	s16 tableData[];
}
</pre></font>

<P>
The <font face="courier" size="-1">order</font> and nEntries fields together determine the length of the <font face="courier" size="-1">tableData</font> field. In the current implementation, <font face="courier" size="-1">order</font>, which defines the ADPCM predictor order, must be 2. <font face="courier" size="-1">nEntries</font> can be anything from 1 to 8. The length of the <font face="courier" size="-1">tableData</font> field is <font face="courier" size="-1">order*nEntries*16</font> bytes.

<P>
The Loop application-specific data contains information necessary to allow the ADPCM decompressor to loop a sound. It has the following structure: 
<pre><font face="courier" size="3">typedef struct { 
	u16 version;	 /* Should be 01 */
	s16 nLoops;
	adpcmLoop loopData[];
}
</pre></font>

<p>
<font face="courier" size="-1">nLoops</font> defines the number of loop points and hence the number of <font face="courier" size="-1">adpcmLoop </font> structures in the chunk. In the current library, only one loop point can be specified. <font face="courier" size="-1">loopData</font> has the following structure:
<pre><font face="courier" size="3">typedef struct { 
	u16 state[16];
	s32 start;
	s32 end;
	s32 count;
} adpcmLoop
</pre></font>

<p>
<font face="courier" size="-1">state</font> defines the internal state of the ADPCM decoder at the start of the loop and is necessary for smooth playback across the loop point. The <font face="courier" size="-1">start</font> and <font face="courier" size="-1">end</font>  values are represented in samples. <font face="courier" size="-1">count</font>  defines the number of times the loop is played before the sound completes. Setting count to -1 indicates that the loop should play indefinitely.

<P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 ALIGN="center">
         <TR><td align="center"><font face="Arial" size="-2" color="#29296B">
Copyright &copy; 1999<br>
Nintendo of America Inc. All Rights Reserved<BR>
Nintendo and N64 are registered trademarks of Nintendo<br>
Last Updated January, 1999</FONT>
</TD></TR></TABLE>
</body>
</html>