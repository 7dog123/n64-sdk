<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<BASE TARGET="main">
<head>
<title>N64 Programming Manual Chapter 1</title>
</head>
<body bgcolor="#FFFFFF">

<table border=0><tr><td><a target="_top" href="../pro01/index1.2.html"><img border=0 src="../images/previous.gif"></a></td>
<td>&nbsp;</td>
<td><a target="_top" href="../pro02/index.html"><img border=0  src="../images/next.gif"></a></td></tr></table>
<P>

<b><font face="arial" color="#29296b">Using the Sample Programs</font></b>

<P>
<font face="arial" size="-1" color="#000000">
The sample programs can be run after installation of the emulator board and software. Directories for the sample programs such as simple or onetri are located under /usr/src/PR/demos. To run the sample programs, run &quot;make&quot; with each directory and enter &quot;gload&quot;. 
<P>
Some of the functions and features of the sample programs are explained below. For a complete description of the features of each sample programs, please review its accompanying README.
<P>

Analyzing and understanding the source code for the sample programs will help you acquire a better understanding of N64 software development.

<P>
<a name="01"></a>
<b>Simple Sample Programs</b>

<p>
<b>blockmonkey</b>
<br>
This is an application that measures a simple performance.  A user 
can change the size of a display list or parameters, and confirm 
the effect when rendering.  Operation instructions for the 
controller are displayed on the host screen when the application is
executed. 
<P>
The graph of performance measurement on the lower screen shows the 
time needed to render a polygon.  The CPU processing time 
needed to create a display list is not calculated. This was done to avoid slowing down the animation even when it cannot catch up with the next frame. 

<P>
<b>fogworld</b>
<br>
This sample program shows how to use the fog process and volume culling process.  This program enables you to output information such the RCP or CPU clock speed, and total available DRAM capacity. 

<P>
<b>onetri</b>
<br>
This is a simple sample program for rendering 1 polygon without the Z-buffer.  By using "gload -a -t", a simple texture mapping is
possible.  

<P>
<b>playseq</b>
<br>
This sample program uses the sequence player.  In the header 
file "playseq.h," the following two types of MAX_VOICES are 
defined (inserted with #ifdef VOICES_16 - #else - #endif):
<pre><font face="courier" size="3">           
                #define MAX_VOICES 16; 
               
                #define MAX_VOICES 32;

</pre></font>

<P>
<b>simple</b>
<br>
This program demonstrates the compatibility of the audio and graphics processes.  In this sample, the audio process will stop the graphics process when the graphics process cannot be completed on time.

<P>
<b>soundmonkey</b>
<br>
A sample program using both the sequence player and the sound 
player.  Only four virtual voices have been prepared for the sequence player in this sample.  Thus, when MIDI data is played, virtual voice allocation fails, and the audio is not performed correctly. If the libgultra_d. a library is linked during make (i.e., if the ERROR=YES argument is attached to execute "make ERROR=YES"), then numerous errors are output to the console.  
<P>      
Since PARTNER-N64 does not support the routine used for outputting
these errors, a program created with the ERROR=YES argument attached 
will not operate on PARTNER-N64. If you are using PARTNER-N64,       please do not execute make with the ERROR=YES argument. Please note that the sample was purposely created like this. This is NOT a bug.  

<P>
<b>spbench</b>
<br>
This program demonstrates the process for displaying a sprite using the sprite library. The number of sprites and color modes can be determined using the Controller. This sample can be used to assist you in learning how to program for high-speed processing.
<P>
MAX_VOICES indicates the number of physical voices of the 
synthesizer and the number of virtual voices of the sequence 
player.  The greater the number of voices, the greater the 
number of sounds that can be played simultaneously. However, this
also increases the amount of processing by the CPU and the RSP.
<P>
Please test both definitions to check the effect of the number of voices.  If compiled without any changes, the number of
virtual voices becomes 32.  

<P>
<b>spin</b>
<br>
This sample program enables you to experiment with RDP functions. Please refer to the README for this sample program for details.

<P>
<b>topgun</b>
<br>
The fighter in this sample program is the .flt format data for 
which modeling was processed by MultiGen. A display list is 
created using the geometry converter flt2c which is included with this sample.   

<P>
<b>turbomonkey</b>
<br>
This is the same as blockmonkey except that is uses the turbo3D microcode.  This sample program verifies the difference between turbo3D microcode and Fast3D microcode on the screen.  A trade-off between image quality and processing speed can be compared using this program and blockmonkey. 


<P>
<a name="02"></a>
<b>High-Level Sample Programs</b>

<p>
<b>autofill</b>
<br>
This is a simple sample program that measures the performance of 
painting out the screen.  This program paints out the screen using a polygon with different aspect ratio size, and measures the speed 
automatically. Use gnuplot to view the measurement data. For details, please refer to README included with this sample program.

<P>
<b>bumpmap</b>
<br>
This is a sample program of bump mapping. For details, please refer to 
the README included with this sample program.

<P>
<b>chrome</b>
<br>
This sample program demonstrates the reflection mapping function.

<P>
<b>ci8fb</b>
<br>
This sample program is similar to autofill.  Rendering is 
processed using an 8 bit color index.  For details, please refer to the
README included with this sample program. 

<P>
<b>cptest</b>
<br>
This sample program uses C++. Please refer to the README included with this sample for additional information.
	 
<P>
<b>detail</b>
<br>
This sample program explains how to use the multi-tiling texture. It includes a demonstration of both the detail texture and MIPmap texture.  
<P>
<b>eeptest</b>
<br>
A simple program to test EEPROM (4k or 16k). When "DEBUG_EEPROM=YES" is specified when executing make, read/writes to 16k areas are performed even for 4k EEPROM.  

<P>
<b>fault</b>
<br>
This sample program processes CPU exceptions without using rmon debugthread.

<P>
<b>ginv</b>
<br>
This program outputs information such as the version of the emulator board equipped on the Indy, RCP and RSP clock speed, and the total amount of available DRAM.

<P>
<b>greset</b>
<br>
This program simulates the operation of pressing the reset button on the hardware.

<P>
<b>ground</b>
<br>
This sample program performs the clipping of a large 
ground plane accurately.

<P>
<b>gs2dex</b>
<br>
This sample program explains how to use the sprite 
microcode S2DEX.

<P>
<b>gtdemo</b>
<br>
In this sample program characters run or punch someone.  This program demonstrates the multiple graphics task. Turbo3D microcode is used a great deal.  Animation is realized using a complex matrix calculation by the host.

<P>
<b>hostio</b>
<br>
This sample program exchanges data between the Indy (host) and the 
game application using the Host-U64 API (Application programmer's
interface).

<P>
<b>lights</b>
<br>
This program expresses a specular highlight effect which uses RSP texture and false shadows (shades). The Controller issued to determine  the location and size of the effect. The background is 
processed with MIP map.

<P>
<b>mipmap</b>
<br>
This program demonstrates MIP mapping.  Verification is possible by 
comparing with other texture processing or changing MIP map
parameters.   

<P>
<b>morphcube</b>
<br>
The CPU calculates each vertex for morphing.  The CPU and the graphics 
pipeline execute 2 frames consecutively in parallel.  Tiling of a 
large MIP map texture is processed with a capacity that is stored 
in texture memory.

<P>
<b>morphfaces</b>
<br>
This program demonstrates morphing of two dimensional images. The CPU processes the morphing of vertex. Blending is performed using 2 cycle mode. For details, please refer to the NOTES file included with this sample program.  

<P>
<b>motortest</b>
<br>
This is a sample program for the Rumble Pak.

<P>
<b>nnsample1</b>
<br>
This is a sample program for the NTSC scheduler.   

<P>
<b>nnsample2</b>
<br>
This is a sample program for the graphics microcode F3DEX Version 1.21 

<P>
<b>nosPak</b>
<br>
This is a sample program for the Controller Pak menu using the N64 font data.  To execute make, please run the batch file makenos.bat. 

<P>
<b>overlay</b>
<br>
This sample program performs the overlay of onetri.code. Two different segments containing codes and data, share the same memory.

<P>
<b>pfs</b>
<br>		
This is a sample program for the Controller Pak.  With this program you can experiment with checking, creating, and deleting game notes. 

<P>
<b>polyline</b>
<br>
This sample program performs rendering by switching microcodes of polygon and line.

<P>
<b>print</b>
<br>
This is a test program to measure the difference in performance of the osSyncPrintf() function when osInitRdb() is used and when osInitRdb() is not used.

<P>
<b>spgame</b>
<br>
This sample program renders objects in the foreground and the 
background using a sprite function.

<P>
<b>spritemonkey</b>
<br>
This program demonstrates the use of the sprite microcode Sprite2D.

<P>
<b>sramtest</b>
<br>
This program tests for the operation of 256K SRAM.  The execution result is displayed with osSyncPrintf(). A 256K SRAM board is required to execute this sample program. 

<P>
<b>terrain</b>
<br>
Use this sample program to create geographical 
features.  This program renders the geometry using N64 hardware. The interface is  operated using the Controller. 

<P>
<b>texlight</b>
<br>
This program expresses a diffuse lighting process, a specular highlight process, and objects which are texture mapped, at the same time.   
             
<P>
<b>tile_rect2d</b>
<br>
This program demonstrates how to divide a large texture	into small texture tiles so it can be stored in a texture memory.    
This program creates two dimensional texture rectangle primitives.

<P>
<b>tile_rect3d</b>
<br>
This sample program explains how to divide a large texture into tiles so it can be stored in a texture memory.  As filtering is processed 
properly, there will be no joints, and a triangle will be created.    

<P>
<b>tron</b>
<br>
A wall is a transparent object which is not sort processed. This sample program demonstrates how to use the BOWTIE_VAL parameter, which avoids RDP hanging.  

<P>
Please see the last section of this manual, <a target="_top" href="../pro29/index.html">"Sample Program Descriptions,"</a> for additional information.

<P>
<a name="03"></a>
<b>About the N64 Online Function Reference Manual</b>
<br>
The "<i>N64 Online Function Reference Manual</i>" provides complete
descriptions of each N64 function and its usage. Please refer to this manual for additional information.

<P>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 ALIGN="center">
         <TR><td align="center"><font face="Arial" size="-2" color="#29296B">
Copyright &copy; 1999<br>
Nintendo of America Inc. All Rights Reserved<BR>
Nintendo and N64 are registered trademarks of Nintendo<br>
Last Updated January, 1999</FONT>
</TD></TR></TABLE>
</body>
</html>