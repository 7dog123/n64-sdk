<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<BASE TARGET="main">
<head>
<title>N64 Programming Manual Chapter 22</title>
</head>
<body bgcolor="#FFFFFF">

<table border=0><tr><td><a target="_top" href="../pro22/index22.1.html"><img border=0 src="../images/previous.gif"></a></td>
<td>&nbsp;</td>
<td><a target="_top" href="../pro23/index23.1.html"><img border=0  src="../images/next.gif"></a></td></tr></table>
<P>

<b><font face="arial" color="#29296b">Using the Scheduler</font></b>

<P>
<font face="arial" size="-1" color="#000000">
The Scheduler is a host CPU thread that addresses the issues discussed above. It is responsible for executing audio and graphics tasks on the RCP such that host and RCP overrun is minimized or eliminated.
<P> 
Each video retrace, the Scheduler reads the new tasks generated by client threads from the task queue and adds them to the end of a real-time (audio) or non-real-time (graphics) task schedule list. 
<P>
If the previous frame’s graphics task has overrun, the Scheduler causes the task to yield. It then runs the next audio task, resuming the yielded task when the audio task has completely processed, and any additional graphics tasks that are to be run to be run in the current frame.

<P>
When a task completes, the Scheduler sends a message to the client indicating that the work it requested is complete.

<P>
<a name="01"></a>
<b>Creating the Scheduler: osCreateScheduler()</b>
<br>
In order to use the Scheduler, you must first call osCreateScheduler() to initialize the OSSched data structure, its message queues and the Vi Manager. The osCreateScheduler() function spawns a thread to schedule and manage task execution. 

<P>
<b>Note:</b> One of the parameters to this call is the thread priority, which should be higher than that of the threads which generate the command lists.

<P>
<a name="02"></a>
<b>Adding Clients to the Scheduler: osScAddClient()</b>
<br>
The Scheduler instantiates the Vi Manager and receives all retrace messages. However, clients of the Scheduler can receive a copy of the retrace message by providing a message queue when they sign in. This is accomplished by calling the osScAddClient() function. 

<P>
<b>Note:</b> One of the parameters to this call is the message queue on which you wish to receive retrace messages. Make sure that the queue is big enough if you don’t want to lose messages, as the Scheduler does not block when the queue is full.

<P>
<a name="03"></a>
<b>Creating Scheduler Tasks: The OSScTask Structure</b>
<br>
In order to send tasks to the Scheduler for execution, you must first create and initialize an OSScTask structure. The structure and a description of its fields is listed below.
<pre><font face="courier" size="3">typedef struct OSScTask_s {
    struct OSScTask_s   *next;
    s32                 state;
    u32			flags;
    void			*framebuffer;	

    OSTask 			list;
    OSMesgQueue			*msgQ;
    OSMesg 			msg;
} OSScTask;
</pre></font>


<p>
<b>Table 1</b> &nbsp;OSScTask structure fields
<br>
<table border=1 cellspacing="3" cellpadding="3" width="90%">
<tr>
<td width=40%><font face="arial" size="-1"><b>Field</td>
<td width=60%><font face="arial" size="-1"><b>Description</b></td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">next</td>
<td width=60%><font face="arial" size="-1">Not used by client (used by the scheduler for list management).
state	Not used by client (used by the scheduler for state management).
framebuffer	Address of the frame buffer for this task (if it is a graphics task).</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">list</td>
<td width=60%><font face="arial" size="-1">Structure containing task code and command list data (described below).</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">msgQ</td>
<td width=60%><font face="arial" size="-1">The message queue on which the client is to receive the task done message.</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">msg</td>
<td width=60%><font face="arial" size="-1">The message that the client is to receive when the task in done.</td>
</tr></table>

<br>
<p>
<b>Table 2</b> &nbsp;OSScTask structure fields
<br>
<table border=1 cellspacing="3" cellpadding="3" width="90%">
<tr>
<td width=40%><font face="arial" size="-1"><b>Field</td>
<td width=60%><font face="arial" size="-1"><b>Description</b></td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">type</td>
<td width=60%><font face="arial" size="-1">Task type; should be initialized to M_AUDTASK for audio tasks or M_GFXTASK for graphics tasks.</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">flags</td>
<td width=60%><font face="arial" size="-1">Various task state bits; should be initialized to 0 for audio tasks, or OS_TASK_DP_WAIT for most graphics tasks
ucode_boot	Pointer to boot microcode; should be initialized to rspbootTextStart.</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">ucode_boot_size</td>
<td width=60%><font face="arial" size="-1">Pointer to boot microcode size in bytes; should be initialized to ((u32)rspbootTextEnd - (u32)rspbootTextStart).</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">ucode</td>
<td width=60%><font face="arial" size="-1">Pointer to task microcode. Should be set to one of gspFast3DTextStart, gspFast3D_dramTextStart, gspLine3DTextStart, or gspLine3D_dramTextStart for graphics tasks; otherwise aspMainTextStart for audio tasks.</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">ucode_size</td>
<td width=60%><font face="arial" size="-1">Size of microcode; should be initialized to SP_UCODE_SIZE.</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">ucode_data</td>
<td width=60%><font face="arial" size="-1">Pointer to task microcode. Should be set to one of gspFast3DDataStart, gspFast3D_dramDataStart, gspLine3DDataStart, or gspLine3D_dramDataStart for graphics tasks; otherwise aspMainDataStart for audio tasks.</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">ucode_data_size</td>
<td width=60%><font face="arial" size="-1">Size of microcode data; should be initialized to SP_UCODE_DATA_SIZE.</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">dram_stack</td>
<td width=60%><font face="arial" size="-1">Pointer to DRAM matrix stack; should be initialized to 0 for audio tasks and to memory region of size SP_DRAM_STACK_SIZE8 bytes.</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">dram_stack_size</td>
<td width=60%><font face="arial" size="-1">DRAM matrix stack size in bytes; should be initialized to 0 for audio tasks or SP_DRAM_STACK_SIZE8 for graphics tasks.</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">output_buff</td>
<td width=60%><font face="arial" size="-1">Pointer to output buffer. The “_dram” versions of the graphics microcode will route the SP output to DRAM rather than to the DP. When this microcode is used, this should point to a memory region to which the SP will write the DP command list.</td>
</tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">output_buff_size</td>
<td width=60%><font face="arial" size="-1">Pointer to store output buffer length. The SP will write the size of the DP command list in bytes to this location.</td></tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">data_ptr</td>
<td width=60%><font face="arial" size="-1">SP command list pointer. For graphics tasks, this is the application constructed display list. For audio tasks, this command list is created by alAudioFrame(3P).</td></tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">data_size</td>
<td width=60%><font face="arial" size="-1">Length of SP command list in bytes.</td></tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">yield_data_ptr</td>
<td width=60%><font face="arial" size="-1">Pointer to buffer to store saved state of yielding task. If the application is going to support preemption of graphics tasks, the graphics tasks should have this structure member set. This should point to a memory region of size OS_YIELD_DATA_SIZE bytes. If task preemption is not supported by the application, this field be initialized to 0. Audio tasks should always set this field to 0.</td></tr>
<tr>
<td width=40% valign="top"><font face="arial" size="-1">yield_data_size</td>
<td width=60%><font face="arial" size="-1">Size of yield buffer in bytes. When task yielding is to be supported by the application, this should be initialized to OS_YIELD_DATA_SIZE for the graphics task. This should always be 0 for audio tasks.</td></tr></table>
		
<P>	
<b>Note:</b> Refer to the osSpTaskLoad man page for information about the alignment restrictions of the data pointers.

<P>
<a name="04"></a>
<b>Sending Tasks to the Scheduler: osScGetTaskQ()</b>
<br>
Once you have created and initialized a Scheduler task, you can send it to the Scheduler thread via the Scheduler’s task queue. You can obtain a pointer to this queue by calling osScGetTaskQ(). 

<P>
The Scheduler will read this task queue after the next retrace message from the Vi Manager. Normally, you will send one audio and one graphics task to the Scheduler each frame.

<P>
<b>Note:</b> After you send the task to the Scheduler, you should not modify it until you receive the “done” message.
<P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 ALIGN="center">
         <TR><td align="center"><font face="Arial" size="-2" color="#29296B">
Copyright &copy; 1999<br>
Nintendo of America Inc. All Rights Reserved<BR>
Nintendo and N64 are registered trademarks of Nintendo<br>
Last Updated January, 1999</FONT>
</TD></TR></TABLE>
</body>
</html>