<html>
<title>
niff2gfx Converter</h1>
</title>

<body bgcolor="#FFFFFF">

<a name="top"></a>

<h1><A NAME="top">niff2gfx Converter</A></h1>
<hr>

<DL>
   <DT><B><A HREF="#OPERATIONMAIN">Operation of niff2gfx</A>
     <DD><A HREF="#FEATURES">Features</A>
     <DD><A HREF="#OPERATION">Command Line Execution</A>
     <DD><A HREF="#OPTIONS">Options</A>
     <DD><A HREF="#INDIRECT">Indirect Filename Specifications</A>
   <DT><A HREF="#OUTPUTSPECS">Output Specifications</A>
     <DD><A HREF="#GBI">GBI Output Specification</A>
     <DD><A HREF="#LIMITATIONS">Limitations</A>
     <DD><A HREF="#CCSETTING">Specification of CC Setting When mat_type Is MAT_TYPE_NIFF</A>
   <DT><A HREF="#CAUTIONS">Programming Cautions</A>
   <DT><A HREF="history.htm">Revision History</A></B>
</DL>


<HR>

<H2><A NAME="OPERATIONMAIN">Operation of niff2gfx</A></H2>

<H3><A NAME="FEATURES">Features</A></H3>

<P>This converter converts NIFF data formatted source files to GBI display-list formatted C source files. It has the following features:</P>

<UL>
<LI>In the display list, the texture that has the greatest effect on performance is placed at the top of the polygon sort for loading.  This design boosts performance.<P>

<LI>This converter applies a high-powered vertex cache algorithm so a higher performance display list is output using N64.<P>

<LI>Object management information is output for the conversion of numerous objects and objects with a hierarchical structure.<P>

<LI>The object management information is analyzed by niffdraw.[ch], which is contained in the accompanying N64 Previewer, so that the object is displayed (display list is called) correctly.<P>

<LI>The corresponding microcode was created based on gspF3DEX.  Therefore, related microcode (spF3DLX, gspF3DLX.Rej, gspF3DLP.Rej, gspL3DEX) can be employed.<P>

<LI>The vertex buffer number can be specified with the -vtxcache option, so each microcode task can output better data.<P>

<LI>Data generated with the so-called semitransparent, decal map N64 functions can be displayed without conflicts so that the object structure + game machine display driver can display objects in accordance with the display order of obj_render_prio.<P>

<LI>Gfx output is split into segments since outside resources such as animation are sometimes operated as resources used inside Gfx. References by those segments are allocated one-by-one to the four types Vtx, Texture Image and TLUT.<P>

<li>Binary files can be output for the n64prev <A HREF="../n64prev/quickprev.htm">Quick Previewer</A>.
</UL>

<!--------------------------------------------------------->
<p><a href="#top">
<img src="../../gif/index.gif"
border="0" width="65" height="17"></a></p>
<!--------------------------------------------------------->

<HR>
<H3><A NAME="OPERATION">Command Line Execution</A></H3>

<P>When <TT>niff2gfx -h</TT> is executed from the command line, the following is displayed.</P>

<blockquote>
<pre>
<font size=3>
NIFF to N64 GBI format convertor. version 1.3.6
supported format revisions: NIFF 1.0
usage: niff2gfx [option] infile outfile
  infile  ... NIFF format file.
  outfile ... N64 Displaylist C source file.
option:
  -q               quiet mode.
  -verbose         verbose mode.
  -header fname, -d fname
                   set output header filename.
  -label str       set label string.(label string = str)
  -scale fval      set convert scale.(scale = (float)fval)
  -niffinfo fname  NIFF information onto file fname.
  -nocomdef        common define,typedef block no output.
  -regmask val     prevent RDP register assignment.
  -vtxshare val    vertex share on set minimum match length.
  -vtxcache val    vertex cache size(default 32).
  -vtxload val     vertex cache load limit(default 32).
  -strictflat      flat normal output to 3 vertices at all times.
  -noalignpad      prevent alignment of 8-byte order no padding.
  -outobj name     output object by name.(default: all objects)
  -outmask val     prevent output dataclass assignment.
  -nogeomclr       geometry mode no clear.
  -preview val     preview type value.(default: 0x1c)
  -binary, -b      output gfx in binary file.
  -rotorder val    default rotation order.(default: 0x010203)
  -vtxseg val      Vtx segment number.(default: 5)
  -imgseg val      image data segment number.(default: 6)
  -tlutseg val     TLUT data segment number.(default: 7)
  -nomodify        disable modify vertex.
  -strictcidx      CIDX pixel/bits follow 'tex_type'.
  -noreduct        CIDX no color reduction.
  -nullanim        output null animation data.
  -?, -h           help
  @fname           indirect option file.
</font>
</pre>
</blockquote>


<!--------------------------------------------------------->
<p><a href="#top">
<img src="../../gif/index.gif"
border="0" width="65" height="17"></a></p>
<!--------------------------------------------------------->

<HR>
<h3><A NAME="OPTIONS">Options</A></h3><p>

<B><FONT FACE="COURIER NEW,COURIER">-header fname, -d fname  &nbsp;&nbsp;&nbsp;   set output header filename</FONT></B><BR>
This switch outputs definition parts of code such as #define and typedef as a separate header file.  Following 
-header, above, please specify a file name to hold the header to be output.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-label str   &nbsp;&nbsp;&nbsp;    set label string. (label string = str)</FONT></B><BR>
The converter outputs all objects in the file that is given as the input.  These objects are output as a table that becomes an interface to the game machine.  The table is also used for the scale value, object total and other define macro names specified at the same time.  That base label name is given.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-scale fval   &nbsp;&nbsp;&nbsp;   set convert scale. (svale = (float)fval)</FONT></B><BR>
This specifies the scale value at conversion time.  In N64, the vertex value is described in the Vtx table as a signed 16-bit integer. So depending on the original model data, rounding off can destroy the original form.  In this case, please specify the option.  The default is set at 20x.<BR>
<BR>

Also, because <B><FONT FACE="COURIER NEW,COURIER">niffdraw.c</FONT></B> performs reverse scaling based on the scale value output to the header, use of the N64 Previewer (or other accessory viewer software) does not affect the scale of the displayed shape.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-niffinfo fname  &nbsp;&nbsp;&nbsp;  NIFF information on to file fname</FONT></B><BR>
This outputs information when a NIFF file is read.  Specify a hyphen ('-') as the filename to write to standard output.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-nocomdef  &nbsp;&nbsp;&nbsp;      common define,typedef block no output</FONT></B><BR>
The converter outputs a lot of header information at the front of the output file (or to the output header file specified with the -header option), but common information unrelated to the model data is suppressed.  This is convenient when using numerous conversion files in a single compiler environment.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-regmask val  &nbsp;&nbsp;&nbsp;   prevent RDP register assignment</FONT></B><BR>
This suppresses output of the RDP register settings in the display list to be output.  A 6-bit integer is assigned to the parameter val.  Each bit has the following function:<BR>
<BR>

<UL><LI>bit0(0x01) ... Suppresses CycleMode setting
<LI>bit1(0x02) ... Suppresses RenderMode setting
<LI>bit2(0x04) ... Suppresses ColorCombinerMode setting
<LI>bit3(0x08) ... Suppresses settings for Primitive color register 
<LI>bit4(0x10) ... Suppresses settings for Environment color register 
<LI>bit5(0x20) ... Suppresses register settings coming to the object header</UL>

<B><FONT FACE="COURIER NEW,COURIER">-vtxshare val  &nbsp;&nbsp;vertex share on set minimum match length</FONT></B><BR>
This specifies a minimum for sharing a vertex buffer.  In order to boost the vertex calculation performance in the RCP at conversion time, niff2gfx makes as much of a consecutive transfer of the vertex buffer as possible.  As a result, the same vertex information is output many times to the vertex table.  At this time, vertex buffers that have already been output are viewed to evaluate whether a continuous part can be shared.  For example, say 10 vertices are to be output as a vertex table.  Normally 10 Vtx are simply output, but when -vtxshare 5 is set if, previously, there was a continuous part of 5 of these 10 vertices, then a past vertex buffer is used to issue the vertex transfer instruction (gsSPVertex).  Note that at this time the number of vertex transfer instructions increases to 2.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-vtxcache val  &nbsp;&nbsp;&nbsp;  vertex cache size(default 32)</FONT></B><BR>
This changes the microcode vertex cache.  With gspF3DEX the vertex cache size is 32. But it increases to 64 with gspF3DLX.Rej, and 80 with gspF3DLP.  When these other microcodes are used, please use this option to increase the vertex cache size for conversions. The default size is 32.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-vtxload val  &nbsp;&nbsp;&nbsp;   vertex cache load limit(default 32)</FONT></B><BR>
This specifies the number of vertices that can be transferred, at once, with gsSPVertex.  This was done for compatibility with gsFast3D. Please do not use this option, because in the present version of the converter the gSPModifyVertex instruction cannot be suppressed.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-strictflat  &nbsp;&nbsp; flat normal output to 3 vertices always</FONT></B><BR>
Usually the converter outputs 1 vertex with face normal, and outputs the other 2 vertices with just the normal for the vertex.  According to the microcode specifications during flat shading, only one of the three vertices needs to express the normal, but for automatic creation of ST values for reflection mapping, all three vertices need to be normal.  Thus, it is necessary to set normal to three vertices only when reflection mapping with flat shading.  This option affects these settings.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-noalignpad   &nbsp;&nbsp;&nbsp;   prevent 8-byte alignment (no padding)</FONT></B><BR>
The converter normally inserts u64 size dummy words in order to maintain 64bit alignment when data is output.  This option suppresses dummy word output.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-outobj name     &nbsp;&nbsp;&nbsp; output object(s) by name</FONT></B><BR>
By default all objects are output by name, so you can use this option when you want to output only a specific object by name.  You can also use this option to specify multiple objects to be output by name.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-outmask val &nbsp;&nbsp;&nbsp; prevent output dataclass assignment</FONT></B><BR>
This restricts the types of data that are output.  An 8-bit integer is assigned to the parameter val.  Each bit is mapped as follows:

<UL><LI>bit0(0x001) ... Header
<LI>bit1(0x002) ... TLUT
<LI>bit2(0x004) ... Bitmap pattern
<LI>bit3(0x008) ... Data related to deforming
<LI>bit4(0x010) ... Shape
<LI>bit5(0x020) ... Vertex list (Vtx structure array)
<LI>bit6(0x040) ... Display list (Gfx structure array)
<LI>bit7(0x080) ... Object structure
<LI>bit8(0x100) ... Animation structure
<LI>bit9(0x200) ... Scene structure
</UL>

When each bit is 1, output of that bit's data class is prohibited. If bit4 is 1, then bit5 and bit6 are also always 1.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-nogeomclr   &nbsp;&nbsp;&nbsp;    geometry mode no clear</FONT></B><BR>
The converter makes Gfx in Shape units, but the default always has gSPClearGeoMode(-1) in the beginning, so the geometry mode is initialized.  This option prevents output of this initialization code.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-binary, -b &nbsp;&nbsp;&nbsp;output gfx in binary file </b></font><br>  
By default, the converter outputs a C source file for the file specified by "outfile." When this option (-binary) is specified, a binary file for Quick Preview is output.  <P>


<B><FONT FACE="COURIER NEW,COURIER">-preview val   &nbsp;&nbsp;&nbsp;  preview val type (default: 0)</FONT></B><BR>
This option was previously used to change the view of the Previewer. However, with the introduction of version 1.30, this option is meaningless - since the Previewer no longer references this value.
<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-rotorder val  &nbsp;&nbsp;&nbsp;  set the default rotation order</FONT></B><BR>
In NIFF, when there is no animation link, no decision is made about the order of animation.  The result is that rotation order can change for every object, and major restrictions are placed on application programming.  This option can be used to set the rotation order for objects that do not hold animation. The original default is 0x010203.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-vtxseg val   &nbsp;&nbsp;  Vtx segment number. (default: 5)</FONT></B><BR>
This specifies the segment number of the vertex buffer referenced by the output Gfx. The default is 5.
<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-imgseg val   &nbsp;&nbsp;  Image data segment number. (default: 6)</FONT></B><BR>
This specifies the segment number of the texture image referenced by the output Gfx. The default value is 6.

<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-tlutseg val   &nbsp;&nbsp;  TLUT data segment number. (default: 7)</FONT></B><BR>
This specifies the segment number of the texture LUT that is referenced by the output Gfx. The default value is 7.
<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-nomodify   &nbsp;&nbsp;  disable modify vertex.</FONT></B><BR>
Prevents gsSPModifyVertex from reusing the vertex buffer. This must be specified when deform is enabled. 
<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-strictcidx   &nbsp;&nbsp;  CIDX pixel/bits follow 'tex_type'.</FONT></B><BR>
When converting, if the image specified as an 8-bit color index texture is less than 16 colors, optimization is usually attempted as a 4-bit texture. However, by specifying this option, the optimization is prohibited and the texture pattern is output by the bit width specified by NIFF.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-noreduct    &nbsp;&nbsp;&nbsp;      CIDX no color reduction.</FONT></B><BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-nullanim    &nbsp;&nbsp;&nbsp;      output null animation data.</FONT></B><BR>If there is no effective animation data in the object, NULL is output to the Animation List. Links to the animation will be created by referring the NULL from the object. nullanim can be used when the animation data is taken from different files. However, it can not be used from the nd since it does not support the Animation List NULL.
<BR>

<br>


<B><FONT FACE="COURIER NEW,COURIER"> @fname    &nbsp;&nbsp;&nbsp;      indirect option file</FONT></B><BR>
fname is taken to be an indirect filename and interpreted as something described by a command line parameter.  For details concerning indirect filenames, please see the "Indirect Filename Specifications" section below.<BR>
<BR>

<B><FONT FACE="COURIER NEW,COURIER">-?, -h     &nbsp;&nbsp;&nbsp;      help</FONT></B><BR>
This outputs simple explanations that describe command line settings and options

<!--------------------------------------------------------->
<p><a href="#top">
<img src="../../gif/index.gif"
border="0" width="65" height="17"></a></p>
<!--------------------------------------------------------->

<HR>
<h3><A NAME="INDIRECT">Indirect Filename Specifications</A></h3>

<ul>
 <li> Files are recognized as various processing system text files.
 <li> For options described in a file, strings divided by one or more white space characters (space, tab, line feed, new page) are taken to be separate words.
 <li> Options are interpreted the same as if they were specified in the command line, so any word with a hyphen placed in front is interpreted as an option.
 <li> An indirect file is expanded and interpreted in the specified place in the command line just like a parameter.
 <li> Numerous indirect files can be specified.
 <li> When '#' is detected at the start of a word, everything from that character to the end of the line (line feed character) is treated as a comment and skipped.
</ul>
<blockquote>
<pre>
Example 1
command line:
  % niff2gfx @ind cube.niff mdl_a.c

"ind" file:
  -header a.h -strictflat

converter parsing...:
  % niff2gfx -header a.h -strictflat cube.niff mdl_a.c

Example 2
command line:
  % niff2gfx @ind

"ind" file:
  # option
  -header model.h
  -regmask 0x5		# no CycleMode & CC mode
  # input file
  cube.niff
  # output file
  model.c

converter parsing...:
  % niff2gfx -header model.h -regmask 0x5 cube.niff model.c

Example 3
command line:
  % niff2gfx @opt @file

"opt" file:
  # option
  -header model.h
  -regmask 0x5		# no CycleMode & CC mode

"file" file:
  cube.niff model.c

converter parsing...:
  Same as in Example 2
</pre>
</blockquote>

<!--------------------------------------------------------->
<p><a href="#top">
<img src="../../gif/index.gif"
border="0" width="65" height="17"></a></p>
<!--------------------------------------------------------->

<hr>
<h2><A NAME="OUTPUTSPECS">Output Specifications</A></h2>

<h3><A NAME="GBI">GBI Output Specification</A></h3>

The GBI output from one NIFF file creates Vtx and Gfx by a unit of Shape. The texture image and TLUT are placed in a single buffer so that they can be used and shared by all Shapes.
<BR>
<BR>

The texture read-in code is created based on the NIFF TextDataArea and the ST value of the attachable face of the texture. Because StData is dependent on the tile information used by N64, at conversion time ST values are scaled and Vtx buffers created in accordance to the size of the texture being applied.<BR>
<BR>

Because there are scenes where Tri and Prim colors are both present, Tri colors are set using the Environment Color Register. Both PrimColReg and EnvColReg can change the color value, irrespective of the material specification for their use.<BR>
<BR>

The texture image supports a total of 9 types: RGBA 32-bit, RGBA 16-bit, index color 8-bit, index color 4-bit, and 1A (16-bit, 8-bit, and 4-bit), and I (8-bit and 4-bit).<BR>
<BR>

To implement a hierarchical object, the object's transform matrix information and link information are stored using a unique data structure called 'nd' along with constant value-based independent data structures.  To get all this done, the machine-use codes <B><FONT FACE="COURIER NEW,COURIER">ndman.c</FONT></B> and <B><FONT FACE="COURIER NEW,COURIER">nddisp.c</FONT></B> are necessary.<BR>
<BR>

The Anm node is used for the object structure's transform data only in the case of <FONT FACE="COURIER NEW,COURIER">ANM_TYPE_STATIC</FONT>. When the transform's rotation information is output by the converter, a Radian to Degree conversion is performed and output to pass the radian value from NIFF.<BR>
<BR>

The low-order 8 bits of the Obj area's obj_pri are evaluated and stored in the priority register of the object structure.

Color reduction is automatically performed when the Tex area texture type is CI and the number of colors used by the image exceeds 256 for an 8-bit color index texture, or 16 for  a 4-bit color index texture.<p>

First, the colors used by the image are reduced to 16-bits (RGBA5551).  The colors are then sorted in order from the most-used. either the first 256 colors are set in the palette for an 8-bit CI texture or the first 16 colors are set in the palette for a 4-bit CI texture.  Since alpha is effective for only 1 bit, it is transparent when the original data is 0, and opaque when the original data is a value other than 0.<p>

If there is no match for a color in the palette, the sum of the difference of squares is calculated for each RGB component and the smallest is selected.<p>

If -noreduct is specified and there are too many colors, the conversion is aborted.<p>

<!--------------------------------------------------------->
<p><a href="#top">
<img src="../../gif/index.gif"
border="0" width="65" height="17"></a></p>
<!--------------------------------------------------------->

<HR>
<H3><A NAME="LIMITATIONS">Limitations</A></H3>

<ul>
<li>The output display list does not comply with the gspFast3D microcode.<p>
<li>RenderMode and ColorCombineMode are set in the display list, so please use the regmask option to mask the register settings for these RDP registers when converting object displays operated by the user.  On the object manager side, please set these masked registers at Gfx expansion time.<p>
<li>When ObjArea's obj_render_pri is OBJ_RENDER_FLAG_NIFF == 1 and OBJ_RENDER_NIFF_*_INTER, OBJ_RENDER_NIFF_*_DECAL, if ShapeArea's shape_area is SHAPE_TYPE_ZB==0, then forcibly change to SHAPE_TYPE_ZB==1.  This is done so there is no Z buffer-invalid INTER, DECAL in RenderMode.<p>
<li>Sometimes the character strings used for symbol names defined in NIFF are used as-is for symbols after conversion.  If data does not compile well after conversion, take note of the symbol information in the NIFF data.<p>
<li>The keyframe animation interpolation method only accommodates LINEAR, and no data outside of LINEAR is output. Light information, global light and local light are not output.<p>
<li>Local light is not output in the light information.<p>
<li> Lighting is assumed ON when MAT_SHADE_USE_HILGHT = 1 or MAT_SHADE_USE_REFLECT = 1 in the Mat area mat_type.  These are given priority since highlight and reflection settings are not effective if lighting is not ON.<p>
</ul>

<!--------------------------------------------------------->
<p><a href="#top">
<img src="../../gif/index.gif"
border="0" width="65" height="17"></a></p>
<!--------------------------------------------------------->

<HR>
<h3><A NAME="CCSETTING">Specification of CC setting when mat_type is MAT_TYPE_NIFF</A></h3>

<h4>Resource Usage Rules</h4>

<blockquote>
      The converter analyzes NIFF data and uses a number of RDP registers.<p>
      The RDP register's Primitive Color register is allocated to PrimColor, while the Environment Color register is allocated to TriColor, and color changes are assigned to the registers.
</blockquote>

<h4>Determining Color Combiner Mode</h4>

<blockquote>
      The color combiner mode is determined based on the MAT_SHADE_LIGHT* of mat_shade_type and the following bits of mat_color_type0:
<pre>
<font size=4>
	MAT_CC_NIFF_VTX        = 0x00000001
	MAT_CC_NIFF_TRI        = 0x00000002
	MAT_CC_NIFF_PRIM       = 0x00000004
	MAT_CC_NIFF_TEX0       = 0x00000008
	MAT_CC_NIFF_TEX1       = 0x00000010
	MAT_CC_NIFF_TRI_ALPHA  = 0x00020000
	MAT_CC_NIFF_PRIM_ALPHA = 0x00040000
	MAT_CC_NIFF_TEX0_ALPHA = 0x00080000
</font>
</pre>
    The following bits are not referenced:
<pre>
<font size=4>
	MAT_CC_NIFF_VTX_ALPHA  = 0x00010000
	MAT_CC_NIFF_TEX1_ALPHA = 0x00100000
</font >
</pre>
    Each bit is assigned separately, so there are a variety of modes.  These are determined in the following way:<p>

     First of all, the color combiner expression is evaluated with the following formula:
<pre>
		(Wch - Xch) * Ych + Zch
</pre>
      Wch, Xch, Ych, and Zch are virtual color channels, and they are determined by different bits in mat_color_type0.
<p>
    Ych is determined by MAT_CC_NIFF_VTX, _TEX0_ALPHA, _PRIM_ALPHA, _TRI_ALPHA, and _VTX_ALPHA.
<p>


<table border>
<tr nowrap>
 <td>VTX_A</td>
 <td>TRI_A</td>
 <td>PRIM_A</td>
 <td>TEX0_A</td>
 <td>VTX</td>
 <td><center>Ych</center></td>
</tr>
<tr nowrap>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77>Shade color</td>
</tr>

<tr nowrap>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77>Vertex color</td>
</tr>

<tr nowrap>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>*</center></td>
<td bgcolor=#FFFF77>Texel0 alpha</td>
</tr>

<tr nowrap>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>*</center></td>
<td><center>*</center></td>
<td bgcolor=#FFFF77>Primitive alpha</td>
</tr>

<tr nowrap>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>*</center></td>
<td><center>*</center></td>
<td><center>*</center></td>
<td bgcolor=#FFFF77>Env alpha</td>
</tr>

<tr nowrap>
<td><center>1</center></td>
<td><center>*</center></td>
<td><center>*</center></td>
<td><center>*</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77>Shade alpha</td>
</tr>

<tr nowrap>
<td><center>1</center></td>
<td><center>*</center></td>
<td><center>*</center></td>
<td><center>*</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77>Vertex alpha</td>
</tr>

</table>

<p>
      In the above table an asterisk (*) refers to an undefined value.  In short, _VTX_ALPHA, _TRI_ALPHA, _PRIM_ALPHA, _TEX0_ALPHA, and _VTX are evaluated in order to set one of the above-mentioned modes.
<p>
      Shade color expresses the color value inferred from calculating SP from the lighting setting and the model's shade.<p>
    When G_LIGHTING is set to off in the GeometryMode settings, Vertex color is extracted from the color value used by the normal of the Vtx structure.
<p>
  <B>Note:</B> When Ych is Shade Color, and when both LOCAL and GLOBAL are 0 (no lighting) in the MAT_SHADE_LIGHT_* settings of mat_shade_type, then the color combiner expression is changed to the following:
<pre>
		(1.0 - Xch) * Wch + Zch
</pre>
      Also note that this special rule does not apply for the second cycle in 2 cycle mode.<p>

Wch, Xch, and Zch are determined from MAT_CC_NIFF_TRI/_PRIM/_TEX0/_TEX1.
<p>


<table border>
<tr nowrap>
<td>TRI</td>
<td>T1/PRIM</td>
<td>TEX0</td>
<td bgcolor=#FFFFFF><center>Wch</center></td>
<td bgcolor=#FFFFFF><center>Xch</center></td>
<td bgcolor=#FFFFFF><center>Zch</center></td>
</tr>
<tr nowrap>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>1.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
</tr>
<tr nowrap>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
</tr>
<tr nowrap>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
</tr>
<tr nowrap>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
</tr>
<tr nowrap>
<td><center>1</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
</tr>
<tr nowrap>
<td><center>1</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
</tr>
<tr nowrap>
<td><center>1</center></td>
<td><center>1</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
</tr>
<tr nowrap>
<td><center>1</center></td>
<td><center>1</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
</tr>
</table>

<p>
      Tex0 indicates Texel0 color.<p>
    Prim indicates the Primitive Color Register.<p>
    Env indicates the Environment Color Register.<p>
  T1/Prim is determined from the states of TEXEL1/PRIMITIVE according to the following rule:<p>


<table border>
<tr nowrap>
<td>TEXEL1</td>
<td>PRIM</td>
<td>T1/Prim</td>
<td>Contents</td>
</tr>
<tr nowrap>
<td><center>0</center></td>
<td><center>0</center></td>
<td bgcolor=#ffff77><center>0</center></td>
<td bgcolor=#ffff77><center>----</center></td>
</tr>
<tr nowrap>
<td><center>0</center></td>
<td><center>1</center></td>
<td bgcolor=#ffff77><center>1</center></td>
<td bgcolor=#ffff77><center>Prim</center></td>
</tr>
<tr nowrap>
<td><center>1</center></td>
<td><center>*</center></td>
<td bgcolor=#ffff77><center>1</center></td>
<td bgcolor=#ffff77><center>TEXEL1</center></td>
</tr>
</table>

<p>
     In 1 cycle mode, the above settings also apply to pipeline 2.<br>
     In 2 cycle mode, the above type of evaluation is not performed on mat_color_type1, and the values are substituted and output in the following way:<p>
	<dd>Shade color is replaced by Combine color <br>
	<dd>Shade Alpha is replaced by Combine Alpha <p>
    

</blockquote>

<h4>Determining Alpha Combiner Mode</h4>

<blockquote>
      Alpha combiner mode is determined based on the following mat_alpha_type0 bits:
<pre>
<font size=4>
	MAT_CC_NIFF_VTX_ALPHA  = 0x00010000
	MAT_CC_NIFF_TRI_ALPHA  = 0x00020000
	MAT_CC_NIFF_PRIM_ALPHA = 0x00040000
	MAT_CC_NIFF_TEX0_ALPHA = 0x00080000
	MAT_CC_NIFF_TEX1_ALPHA = 0x00100000
</font >
</pre>

    The following bits are not referenced:
<pre>
<font size=4>
	MAT_CC_NIFF_VTX  = 0x00000001
	MAT_CC_NIFF_TRI  = 0x00000002
	MAT_CC_NIFF_PRIM = 0x00000004
	MAT_CC_NIFF_TEX0 = 0x00000008
	MAT_CC_NIFF_TEX1 = 0x00000010
</font >
</pre>
      The alpha combiner expression is defined in the same way as the color combiner expression:
<pre>
<font size=4>
		(Wch - Xch) * Ych + Zch
</font >
</pre>
    The Wch, Xch, Ych, and Zch channels are determined based on the five effective flags described above, and according to the following rule:<p>

<table border>
<tr nowrap>
<td><center>VTX_A</center></td>
<td><center>TRI_A</center></td>
<td><center>T1/PRIM</center></td>
<td><center>TEX0_A</center></td>
<td bgcolor=#FFFFFF><center>Wch</center></td>
<td bgcolor=#FFFFFF><center>Xch</center></td>
<td bgcolor=#FFFFFF><center>Ych</center></td>
<td bgcolor=#FFFFFF><center>Zch</center></td>
</tr>
<tr>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>1.0</center></td>
</tr>
<tr>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
</tr>
<tr>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
</tr>
<tr>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
</tr>
<tr>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
</tr>
<tr>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
</tr>
<tr>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>1</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
</tr>
<tr>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>1</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
</tr>
<tr>
<td><center>1</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>Shade</center></td>
</tr>
<tr>
<td><center>1</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>Shade</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
</tr>
<tr>
<td><center>1</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>Shade</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
</tr>
<tr>
<td><center>1</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>Shade</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
</tr>

<tr>
<td><center>1</center></td>
<td><center>1</center></td>
<td><center>0</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>Shade</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
<td bgcolor=#FFFF77><center>0.0</center></td>
</tr>
<tr>
<td><center>1</center></td>
<td><center>1</center></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>Shade</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
</tr>
<tr>
<td><center>1</center></td>
<td><center>1</center></td>
<td><center>1</center></td>
<td><center>0</center></td>
<td bgcolor=#FFFF77><center>Shade</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
</tr>
<tr>
<td><center>1</center></td>
<td><center>1</center></td>
<td><center>1</center></td>
<td><center>1</center></td>
<td bgcolor=#FFFF77><center>Shade</center></td>
<td bgcolor=#FFFF77><center>T1/Prim</center></td>
<td bgcolor=#FFFF77><center>Tex0</center></td>
<td bgcolor=#FFFF77><center>Env</center></td>
</tr>

</table>

<p>
    VTX_ALPHA becomes a control flag for ShadeColor.
<p>
  T1/Prim is determined from the states of TEXEL1/PRIMITIVE according to the following rule:<p>


<table border>
<tr nowrap>
<td>TEXEL1_A</td>
<td>PRIM_A</td>
<td>T1/Prim</td>
<td>Contents</td>
</tr>
<tr nowrap>
<td><center>0</center></td>
<td><center>0</center></td>
<td bgcolor=#ffff77><center>0</center></td>
<td bgcolor=#ffff77><center>----</center></td>
</tr>
<tr nowrap>
<td><center>0</center></td>
<td><center>1</center></td>
<td bgcolor=#ffff77><center>1</center></td>
<td bgcolor=#ffff77><center>Prim</center></td>
</tr>
<tr nowrap>
<td><center>1</center></td>
<td><center>*</center></td>
<td bgcolor=#ffff77><center>1</center></td>
<td bgcolor=#ffff77><center>TEXEL1</center></td>
</tr>
</table>

<p>
    In 1 cycle mode, the above settings also apply to pipeline 2.<br>
    In 2 cycle mode, the above type of evaluation is not performed on mat_color_type1, and the output value for Shade Alpha is replaced by Combine alpha and output.
<p>
</blockquote>
</blockquote>
<p>

<!--------------------------------------------------------->
<p><a href="#top">
<img src="../../gif/index.gif"
border="0" width="65" height="17"></a></p>
<!--------------------------------------------------------->

<hr>

<h2><A NAME="CAUTIONS">Programming Cautions</A></h2>

<UL>
<P><LI>Because N64 can handle texture patterns that do not satisfy TMEM size by dividing them for loading, repeated drawing, and tile definition; this converter handles large texture patterns as-is.  As a result, even when only part of a texture pattern can be used, the entire pattern is output.

<P><LI>When a large texture is divided and texture-mapped, texture wrapping (repeats) can no longer be performed.  Sometimes the texture load for the border of the texture pattern requires four tile loads in order to create a single draw tile, and the draw tile settings can become extremely complicated.  The tile load and tile settings alone take up a considerable amount of the display list, and it is too costly in terms of processing to properly map 4K bytes of TMEM.  With this converter, wrapping cannot be carried out in compensation for texture mapping, provided the texture that do not finish in the size of TMEM (4K bytes) is divided well.

<P><LI>When setting a tile, a read-in range for the texture -- uls, ult, lrs, and lrt -- are determined from the texture coordinate value (S,T) of the polygon.  At this time, lrs and lrt are obtained  from the lower right ST value.  However, bilinear interpolation is a prerequisite for the converter. Therefore, a range 1 texel larger than the texel at the lower-right ST value is read into TMEM. If the user arbitrarily divides the texture exceeding the TMEM contents among polygons, and each division range maps ST in te maximum TMEM range, then a single texture read range will exceed the TMEM range, and the texture will be destroyed when displayed.

  <UL>
  <P>For example:

  <P><LI>A 64 x 32 texture that does not fit in TMEM is to be stretched over a square polygon while bilinear interpolation remains effective.  Think of it as dividing the texture down the middle and stretching it over two 32 x 32 square polygons.

  <P><LI>You can think of a square polygon starting from the left at pixel 0 to pixel 31, and another polygon adjoining it from pixel 32 to 63. But because bilinear interpolation is necessary from the 31st to 32nd pixel, 33 x 33 pixels must be loaded for the texture.  The converter can evaluate this, but it cannot evaluate whether the texture tiles fit in 4K of TMEM.

  <P><LI>When you prepare on the assumption of an exact fit in TMEM, sometimes the pattern will break down.
  </UL>

<P><LI>Billboard objects are evaluated, but not tested.  Also, the problem of hangups remains with the LookAt function when the upward vector and the direction of view are the same (or exactly opposite).
</UL>

<!----------End of Document----------------------------------------------->

<hr>

<P><font size=-1>Copyright 1997-1999 NINTENDO Co., Ltd. <BR>
1998-1999 MONEGI CORPORATION <BR>
All rights reserved.</font></P>

<!--------------------------------------------------------->
<p><a href="#top">
<img src="../../gif/index.gif"
border="0" width="65" height="17"></a></p>
<!--------------------------------------------------------->

</body>
</html>