<html>
<head>
<title>NVF Specification</title>
</head>
<body bgcolor="#FFFFFF">

<h1><A NAME="top">NVF Specification</A></h1>

<ol>
 <li><a href="#place">NVF Intro</a>
 <li><a href="#structure">Basic Structure of NVF</a>
 <li><a href="#noderef">NVF Node Reference</a>
 <li><a href="#limitation">Problems / Limitations</a>
</ol>

 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="place"><h3>Introduction to NVF</h3></a>

Whereas NIFF is designed as an intermediate format, created by converting the CG tool data,  NVF is designed as a format closer to the target, meant for displaying NIFF on the N64.  NIFF is converted to NVF and then stored in the N64 ROM area.  The previewer (<a href="../nvfview/seg1.htm">nvfview</a>, etc.) loads NVF from the N64 ROM area into main memory and then displays the data.

<p align="right">
 <a href="index.htm">Index
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="structure"><h3>The Basic Structure of NVF</h3></a>

<h4>Data Types</h4>
The following basic data types were defined in NVF:
<ul>
 <li>long<br>
  A 4-byte integer.  Uses the network byte order.
 <li>short<br>
  A 2-byte integer.  Uses the network byte order.
 <li>char<br>
  A 1-byte integer.
 <li>float<br>
  A 4-byte floating-point.  Follows the IEEE 754 format shown below:
  <table border="1">
   <tr>
    <td width="25%" colspan="8" align="center">Byte 0</td>
    <td width="25%" colspan="8" align="center">Byte 1</td>
    <td width="25%" colspan="8" align="center">Byte 2</td>
    <td width="25%" colspan="8" align="center">Byte 3</td>
   </tr>
   <tr>
    <td colspan="1">Sign: 1</td>
    <td colspan="8">Exponent: 8</td>
    <td colspan="23">Coefficient: 23</td>
   </tr>
  </table>
 <li>node<br>
  A 4-byte integer specifying the node index.  However, the following values have special interpretations:
  <dl>
   <dt>0xFFFFFFFF
   <dd>Indicates that the node is NULL.
   <dt>0x80000000 ~ 0xFFFFFFFE
   <dd>Indicates that the node exists in an external NVF.
    In this case, the lower 31 bits comprise the index of the external node table.
  </dl>
</ul>

<h4>Format</h4>
NVF was created based on IFF.  (Although NIFF and IFF have similar names, they are completely unrelated.)
<p>
The IFF file is composed of fixed format Chunks.
<table border="1">
 <tr>
  <td align="center">CHUNK MAGIC 4 bytes</td>
 </tr>
 <tr>
  <td align="center">CHUNK DATA SIZE 4 bytes</td>
 </tr>
 <tr>
  <td align="center">DATA<br>The length is the byte size specified by CHUNK DATA SIZE.</td>
 </tr>
</table>
<p>
However, the Chunks are not enumerated as they are in the file.  There is a special Chunk called 'FORM' which comprises a number of Chunks, and all the Chunks are contained in this.  At the present time, one file can contain only one FORM.
<table border="1">
 <tr>
  <td colspan="2" align="center">CHUNK MAGIC 4 bytes ('FORM')</td>
 </tr>
 <tr>
  <td colspan="2" align="center">CHUNK DATA SIZE 4 bytes</td>
 </tr>
 <tr>
  <td rowspan="4">DATA</td><td align="center">FORM MAGIC 4 bytes 'NVFB'</td>
 </tr>
 <tr>
  <td align="center">CHUNK 1</td>
 <tr>
  <td align="center">CHUNK 2</td>
 </tr>
 <tr>
  <td align="center">....</td>
 </tr>
</table>
<p>
In NVF, 1 Chunk expresses 1 node.  There are various types of nodes, and each of them has its own Chunk Magic.  However, there are three kinds of Chunks which are used for purposes other than nodes, as described below.

<ul>
 <li>'NHDR'<br>
  This is the header.  It holds information relating to the entire NVF.  Naturally, it appears only once in the form.  The format is shown below.
  <blockquote>
   <pre>
  Header 'NHDR' {
    long    num_of_nodes
    long    num_of_root_nodes
    long    root_node_index[num_of_root_nodes]
    long    symbol_table_size
    char    symbol_table[symbol_table_size]
    long    comment_size
    char    comment[comment_size]
  }
   </pre>
  </blockquote>
 <li>'REFR'<br>
  This Chunk describes the relationship between nodes.  It appears only once in the form.  The format is shown below.
  <blockquote>
   <pre>
  ReferenceList 'REFR' {
    long    num_of_references
    {
      short type( 0: FtoF, 1: FtoL, 2: LtoF, 3: LtoL )
      short size
      node  target
      short target_field
      short target_index
      node  reference
      short reference_field
      short reference_index
    } reference[num_of_references]
  }
   </pre>
  </blockquote>
 <li>'XTRN'<br>
  This Chunk describes external nodes.  It appears only once in the form.  The format is shown below.
  <blockquote>
   <pre>
  ExternalSymbolList 'XTRN' {
    long    num_of_symbols
    {
      long   module_id
      long   node_name_entry
    } symbol[num_of_symbols]
  }
   </pre>
  </blockquote>
</ul>

<p align="right">
 <a href="index.htm">Index
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="noderef">
<h3>
NVF Node Reference
</h3>
<table border="1">
 <tr>
  <td width="30%" valign="top">
   <table border="0">
    <tr>
     <td>AGEO</td><td><a href="#AnimatedGeometry">AnimatedGeometry</a></td>
    </tr>
    <tr>
     <td>ANMF</td><td><a href="#Animation">Animation</a></td>
    </tr>
    <tr>
     <td>CSCL</td><td><a href="#ClassicScale">ClassicScale</a></td>
    </tr>
    <tr>
     <td>FNCC</td><td><a href="#ConstantFunction">ConstantFunction</a></td>
    </tr>
    <tr>
     <td>DFOG</td><td><a href="#DepthFog">DepthFog</a></td>
    </tr>
    <tr>
     <td>DRUC</td><td><a href="#DirUpConstraint">DirUpConstraint</a></td>
    </tr>
    <tr>
     <td>DIRC</td><td><a href="#DirectionConstraint">DirectionConstraint</a></td>
    </tr>
    <tr>
     <td>LGTD</td><td><a href="#DirectionalLight">DirectionalLight</a></td>
    </tr>
    <tr>
     <td>ENVG</td><td><a href="#EnvelopeGeometry">EnvelopeGeometry</a></td>
    </tr>
    <tr>
     <td>EVVC</td><td><a href="#EnvelopeVertexC">EnvelopeVertexC</a></td>
    </tr>
    <tr>
     <td>EVVN</td><td><a href="#EnvelopeVertexN">EnvelopeVertexN</a></td>
    </tr>
    <tr>
     <td>FLOT</td><td><a href="#Float">Float</a></td>
    </tr>
    <tr>
     <td>GEOM</td><td><a href="#Geometry">Geometry</a></td>
    </tr>
    <tr>
     <td>FNCH</td><td><a href="#HermiteFunction">HermiteFunction</a></td>
    </tr>
   </table>
  </td>
  <td width="30%" valign="top">
   <table border="0">
    <tr>
     <td>LTST</td><td><a href="#LightSet">LightSet</a></td>
    </tr>
    <tr>
     <td>FNCL</td><td><a href="#LinearFunction">LinearFunction</a></td>
    </tr>
    <tr>
     <td>LODD</td><td><a href="#Lod">Lod</a></td>
    </tr>
    <tr>
     <td>MRKR</td><td><a href="#Marker">Marker</a></td>
    </tr>
    <tr>
     <td>MTRL</td><td><a href="#Material">Material</a></td>
    </tr>
    <tr>
     <td>MDUL</td><td><a href="#Module">Module</a></td>
    </tr>
    <tr>
     <td>NOPR</td><td><a href="#Nop">Nop</a></td>
    </tr>
    <tr>
     <td>ORNT</td><td><a href="#Orientation">Orientation</a></td>
    </tr>
    <tr>
     <td>ORIC</td><td><a href="#OrientationConstraint">OrientationConstraint</a></td>
    </tr>
    <tr>
     <td>PCAM</td><td><a href="#PerspectiveCamera">PerspectiveCamera</a></td>
    </tr>
    <tr>
     <td>POSC</td><td><a href="#PositionConstraint">PositionConstraint</a></td>
    </tr>
    <tr>
     <td>RXYZ</td><td><a href="#RotationXYZ">RotationXYZ</a></td>
    </tr>
    <tr>
     <td>ROTY</td><td><a href="#RotationY">RotationY</a></td>
    </tr>
    <tr>
     <td>RZXY</td><td><a href="#RotationZXY">RotationZXY</a></td>
    </tr>
   </table>
  </td>
  <td width="30%" valign="top">
   <table border="0">
    <tr>
     <td>SCAL</td><td><a href="#Scale">Scale</a></td>
    </tr>
    <tr>
     <td>SHAP</td><td><a href="#Shape">Shape</a></td>
    </tr>
    <tr>
     <td>SK22</td><td><a href="#Skeleton2d2">Skeleton2d2</a></td>
    </tr>
    <tr>
     <td>SKP2</td><td><a href="#SkeletonPx2">SkeletonPx2</a></td>
    </tr>
    <tr>
     <td>SKU2</td><td><a href="#SkeletonUv2">SkeletonUv2</a></td>
    </tr>
    <tr>
     <td>SWCH</td><td><a href="#Switch">Switch</a></td>
    </tr>
    <tr>
     <td>TXTR</td><td><a href="#Texture">Texture</a></td>
    </tr>
    <tr>
     <td>TXIM</td><td><a href="#TextureImage">TextureImage</a></td>
    </tr>
    <tr>
     <td>TLUT</td><td><a href="#TextureLut">TextureLut</a></td>
    </tr>
    <tr>
     <td>XFMI</td><td><a href="#TransformInfo">TransformInfo</a></td>
    </tr>
    <tr>
     <td>XLAT</td><td><a href="#Translation">Translation</a></td>
    </tr>
    <tr>
     <td>VTXI</td><td><a href="#VertexInterpolator">VertexInterpolator</a></td>
    </tr>
   </table>
  </td>
 </tr>
</table>

<p align="right">
 <a href="index.htm">Index
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="AnimatedGeometry">
<h3>AnimatedGeometry</h3>
<blockquote>
 <pre>
  AnimatedGeometry 'AGEO' {
    long    name_entry
    node    vertex
    float   time        :0
  }
 </pre>
</blockquote>
  Defines geometry with attached animation.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Animation">
<h3>Animation</h3>
<blockquote>
 <pre>
  Animation 'ANMF' {
    long    name_entry
    long    num_of_elements
    long    num_of_functions
    long    function_index               :0
    float   time                         :1
    float   value[num_of_elements]       :2
    float   diffential[num_of_elements]  :3
    node    function[num_of_functions]
  }
 </pre>
</blockquote>
  Defines floating point vector animation.  num_of_elements indicates the size of vector.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="ClassicScale">
<h3>ClassicScale</h3>
<blockquote>
 <pre>
  ClassicalScale 'CSCL' {
    long    name_entry
    float3  scale               :0
    long    num_of_children
    node    child[num_of_children]
  output:
    float9  scaled_orientation  :1
  }
 </pre>
</blockquote>
  ClassicScale specifies the scaling rate, or degree of enlargement.  All children are influenced by this coordinate transformation.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="ConstantFunction">
<h3>ConstantFunction</h3>
<blockquote>
 <pre>
  ConstantFunction 'FNCC' {
    long    name_entry
    char    num_of_elements
    char    continuity
            # 0: Noncontinuous
            # 1: C0 Continuous
            # 2: C1 Continuous
    long    num_of_keys
    float   junction
            # The junction point time for continuous animation.
            # It is ignored for noncontinuous animation.
            # At the present time, junction is not yet functional.
    {
      float time
      float value[num_of_elements]
    } key[num_of_keys]
  }
 </pre>
</blockquote>
  Defines the animation keyframe function.  ConstantFunction switches constants over time, so you could call it a zero-order interpolation function.  The function node is not functional on its own.  It starts functioning after being referenced from the animation node.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="DepthFog">
<h3>DepthFog</h3>
<blockquote>
 <pre>
  Fog 'DFOG' {
    long    name_entry
    float   fog_near   :0
    float   fog_far    :1
    float4  fog_color  :2
  }
 </pre>
</blockquote>
  Sets the Fog.  The behavior when effective Fog appears in the scene graph numerous times is undefined.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="DirUpConstraint">
<h3>DirUpConstraint</h3>
<blockquote>
 <pre>
  DirUpConstraint 'DRUC' {
    long    name_entry
    float3  direction           :0
    float3  up_vector           :1
    long    num_of_children
    node    child[num_of_children]
  output:
    float9  global_orientation  :2
  }
 </pre>
</blockquote>
  DirUpConstraint turns the X axis to the direction of the global "direction" and the Y axis to the direction of the global "up_vector."  However, the Y axis is corrected so that it is at a right angle to the X axis.  All children are influenced by this coordinate transformation.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="DirectionConstraint">
<h3>DirectionConstraint</h3>
<blockquote>
 <pre>

  DirConstraint 'DIRC' {
    long    name_entry
    float3  direction           :0
    long    num_of_children
    node    child[num_of_children]
  output:
    float9  global_orientation  :1
  }
 </pre>
</blockquote>
  DirConstraint turns the X axis to the direction of the global "direction."  The Y axis is corrected so that it is orthogonal to the X axis.  All children are influenced by this coordinate transformation.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="DirectionalLight">
<h3>DirectionalLight</h3>
<blockquote>
 <pre>
  DirectionalLight 'LGTD' {
    long    name_entry
    float3  direction  :0
    float3  color      :1
            # Values from 0 ~ 1.
  }
 </pre>
</blockquote>
  Defines the directional light source.  The light source node does not function on its own.  It starts functioning after being referenced from the light source set node.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="EnvelopeGeometry">
<h3>EnvelopeGeometry</h3>
<blockquote>
 <pre>
  EnvelopeGeometry 'ENVG' {
    long    name_entry
    node    vertex
    long    num_of_joints
    {
      float9 orientation  :0 (index = joint_index * 9)
      float3 translation  :1 (index = joint_index * 3)
      float3 scale        :2 (index = joint_index * 3)
    } joint[num_of_joints]
  }
 </pre>
</blockquote>
  Defines the geometry of the Flexible envelope.  The vertex type must be either EnvelopeVertexC or EnvelopeVertexN.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="EnvelopeVertexC">
<h3>EnvelopeVertexC</h3>
<blockquote>
 <pre>
  EnvelopeVertexC 'EVVC' {
    long    name_entry
    long    segment
    short   num_of_joints
    short   num_of_rigid_groups
    short   num_of_morph_groups
    short   num_of_combine_groups
    long    num_of_vertex_groups

    # The following is the description for all rigid groups:
    {
      short  joint_index
      short  num_of_vertices
      {
        short3  coord
        char4   normal/color
        short2  tex_coord
      } vtx[num_of_vertices]
    } rigid_group[num_of_rigid_groups]

    # The following is the description for all morph groups:
    {
      short  primary_joint_index
      short  secondary_joint_index
      short  num_of_vertices
      short  num_of_coords
      short  table_size
             # At present, 9, 17, 33 and 65 are supported.
      {
        float3  coord[num_of_coords]
      } table[table_size]
      {
        short   coord_index
        char4   color
        short2  tex_coord
      } vtx[num_of_vertices]
    } morph_group[num_of_morph_groups]

    # The following is the description for all combine groups:
    {
      short  num_of_vertices
      short  num_of_coords
      short  num_of_joint_groups
      {
        short  joint_index
        short  num_of_joint_vertices
        {
          short   vtx_index
          float3  coord
                  # The result of multiplying the actual "coord" by "weight"
          float   weight
        } joint_vertex[num_of_joint_vertices]
      } joint_group[num_of_joint_groups]
      {
        short   coord_index
        char4   color
        short2  tex_coord
      } vtx[num_of_vertices]
    } combine_group[num_of_combine_groups]

    # The following is information for triangle setup:
    {
      short   rigid_group_index
      short   rigid_vtx_offset
      char    rigid_vtx_cache_offset
      char    rigid_vtx_load_count
      short   morph_group_index
      short   morph_vtx_offset
      char    morph_vtx_cache_offset
      char    morph_vtx_load_count
      short   combine_group_index
      short   combine_vtx_offset
      char    combine_vtx_cache_offset
      char    combine_vtx_load_count
      long    num_of_modification_group
      {
        char    num_of_rgba_modification
        char    num_of_st_modification
        char    num_of_xy_modification
        char    num_of_z_modification
        long    num_of_triangles
        {
          char    vertex_index
          char4   rgba
        } rgba_modification[num_of_rgba_modification]
        {
          char    vertex_index
          short2  st
        } st_modification[num_of_st_modification]
        {
          char    vertex_index
          short2  xy
        } xy_modification[num_of_xy_modification]
        {
          char    vertex_index
          long    z
        } z_modification[num_of_z_modification]
        char3   triangle[num_of_triangles]
      } modification_group[num_of_modification_group]
    } vertex_group[num_of_vertex_groups]
  }
 </pre>
</blockquote>
  Defines the vertices of the Flexible Envelope.  However, normals are not calculated.  (Therefore, lighting is impossible.)  The vertices of the Flexible Envelope are classified into three types: rigid vertex, morph vertex and combine vertex.  
<ol>
 <li> A rigid vertex is a vertex which has 100% weight for any and every joint.
 <li> A morph vertex is a vertex which has weight for only two joints.  The inner product of the x axes of the two joints works as a parameter to change the weight.
 <li> A combine vertex refers to all other vertices.
</ol>
  The method for calculating each type of vertex is explained below.
<ul>
 <li>Rigid vertex<br>
    The transformation matrix of the joint is used for the coordinate transformation, just like in a conventional coordinate transformation.
 <li>Morph vertex<br>
    The angles of the two joints are used as parameters for morphing.  A table is created in degree units of 180/(the number of tables - 1).
 <li>Combine vertex<br>
    The basic implementation for weighted vertices.
</ul>

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="EnvelopeVertexN">
<h3>EnvelopeVertexN</h3>
<blockquote>
 <pre>
  EnvelopeVertexN 'EVVN' {
    long    name_entry
    long    segment
    short   num_of_joints
    short   num_of_rigid_groups
    short   num_of_morph_groups
    short   num_of_combine_groups
    long    num_of_vertex_groups

    # The following is the description for all rigid groups:
    {
      short  joint_index
      short  num_of_vertices
      {
        short3  coord
        char4   normal/color
        short2  tex_coord
      } vtx[num_of_vertices]
    } rigid_group[num_of_rigid_groups]

    # The following is the description for all morph groups:
    {
      short  primary_joint_index
      short  secondary_joint_index
      short  num_of_vertices
      short  num_of_coords
      short  num_of_normals
      short  table_size
             # At present, 9, 17, 33 and 65 are supported.
      {
        float3  coord[num_of_coords]
        float3  normal[num_of_normals]
      } table[table_size]
      {
        short   coord_index
        short   normal_index
        short2  tex_coord
      } vtx[num_of_vertices]
    } morph_group[num_of_morph_groups]

    # The following is the description for all combine groups:
    {
      short  num_of_vertices
      short  num_of_coords
      short  num_of_normals
      short  num_of_joint_groups
      {
        short  joint_index
        short  num_of_joint_coords
        short  num_of_joint_normals
        {
          short   coord_index
          float3  coord
                  #  The result of multiplying the actual "coord" by "weight"
          float   weight
        } joint_vertex[num_of_joint_coords]
        {
          short   normal_index
          float3  normal
                  #  The result of multiplying the actual "normal" by "weight"
        } joint_vertex[num_of_joint_normals]
      } joint_group[num_of_joint_groups]
      {
        short   coord_index
        short   normal_index
        short2  tex_coord
      } vtx[num_of_vertices]
    } combine_group[num_of_combine_groups]

    # The following is the information for triangle setup:
    {
      short   rigid_group_index
      short   rigid_vtx_offset
      char    rigid_vtx_cache_offset
      char    rigid_vtx_load_count
      short   morph_group_index
      short   morph_vtx_offset
      char    morph_vtx_cache_offset
      char    morph_vtx_load_count
      short   combine_group_index
      short   combine_vtx_offset
      char    combine_vtx_cache_offset
      char    combine_vtx_load_count
      long    num_of_modification_group
      {
        char    num_of_rgba_modification
        char    num_of_st_modification
        char    num_of_xy_modification
        char    num_of_z_modification
        long    num_of_triangles
        {
          char    vertex_index
          char4   rgba
        } rgba_modification[num_of_rgba_modification]
        {
          char    vertex_index
          short2  st
        } st_modification[num_of_st_modification]
        {
          char    vertex_index
          short2  xy
        } xy_modification[num_of_xy_modification]
        {
          char    vertex_index
          long    z
        } z_modification[num_of_z_modification]
        char3   triangle[num_of_triangles]
      } modification_group[num_of_modification_group]
    } vertex_group[num_of_vertex_groups]
  }
 </pre>
</blockquote>
  Defines the vertices of the Flexible Envelope.  Unlike <a href="#EnvelopeVertexC">EnvelopeVertexC</a>, normal lines are also calculated.  (In other words, Lighting is possible.)  The data contents are almost the same as for EnvelopeVertexC.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Float">
<h3>Float</h3>
<blockquote>
 <pre>
  Float 'FLOT' {
    long    name_entry
    long    num_of_elements
    float   value[ num_of_elements ]  :0
  }
 </pre>
</blockquote>
This does nothing except hold floating point values.  It is convenient for collectively managing the values set in the time field of Animation, etc..  

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Geometry">
<h3>Geometry</h3>
<blockquote>
 <pre>
  Geometry 'GEOM' {
    long    name_entry
    long    segment
    long    num_of_vertices
    {
      short3  coord
      char4   normal/color
      short2  tex_coord
    } vtx[num_of_vertices]
    long    num_of_vertex_groups
    {
      short   vertex_offset
      char    vertex_cache_offset
      char    vertex_load_count
              # The above three parameters are for vertex loading.
      long    num_of_modification_group
      {
        char    num_of_rgba_modification
        char    num_of_st_modification
        char    num_of_xy_modification
        char    num_of_z_modification
        long    num_of_triangles
        {
          char    vertex_index
          char4   rgba
        } rgba_modification[num_of_rgba_modification]
        {
          char    vertex_index
          short2  st
        } st_modification[num_of_st_modification]
        {
          char    vertex_index
          short2  xy
        } xy_modification[num_of_xy_modification]
        {
          char    vertex_index
          long    z
        } z_modification[num_of_z_modification]
          # The above parameters are the vertex-change parameters.
        char3   triangle[num_of_triangles]
      } modification_group[num_of_modifi_group]
    } vertex_group[num_of_vertex_groups]
  }
 </pre>
</blockquote>
  Defines the geometry.  In Geometry, triangles are classified according to their modification_group.  A number of modification_groups are then gathered together forming a vertex_group.  The Geometry drawing process is illustrated below.

<blockquote>
 <pre>
  for each vertex_group do
    Read vertices into vertex cache.
    for each modification_group do
      Changes the vertices in accordance with the vertex-change parameters.  
      Draw triangles.
    done
  done
 </pre>
</blockquote>

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="HermiteFunction">
<h3>HermiteFunction</h3>
<blockquote>
 <pre>
  HermiteFunction 'FNCH' {
    long    name_entry
    char    num_of_elements
    char    continuity
            # 0: Discontinuous
            # 1: C0 Continuous
            # 2: C1 Continuous
    long    num_of_keys
    float   junction
            # At present, junction is not yet functional.
    {
      float time
      float value[num_of_elements]
      float differential[num_of_elements]
    } key[num_of_keys]
  }
 </pre>
</blockquote>

<P>Defines a key frame function of animation. HermiteFunction is a trilinear interpolation function. A function node does not function alone. It will function only after it is referenced from an animation node. The interpolation formula is as follows:</P>

<center>
<IMG SRC="Image1.gif">then <p>
<IMG SRC="Image2.gif"><p>
</center>

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="LightSet">
<h3>LightSet</h3>
<blockquote>
 <pre>
  LightSet 'LTST' {
    long    name_entry
    float3  ambient  :0
            # Values from 0 ~ 1.
    long    num_of_lights
    node    lights[num_of_lights]
  }
 </pre>
</blockquote>
  Defines a set of light sources.  This node is related to the material node and performs lighting.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="LinearFunction">
<h3>LinearFunction</h3>
<blockquote>
 <pre>
  LinearFunction 'FNCL' {
    long    name_entry
    char    num_of_elements
    char    continuity
            # 0: Discontinuous
            # 1: C0 Continuous
            # 2: C1 Continuous
    long    num_of_keys
    float   junction
            # At present, junction is not yet functional.
    {
      float time
      float value[num_of_elements]
    } key[num_of_keys]
  }
 </pre>
</blockquote>
  Defines the animation keyframe function.  LinearFunction is a first-order interpolation function.  The function node is not functional on its own.  It starts functioning after being referenced from the animation node.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Lod">
<h3>Lod</h3>
<blockquote>
 <pre>
  LOD 'LODD' {
    long    name_entry
    char    group( 0 ~ 31 )
    char    num_of_levels
    float   range[num_of_levels-1]
    node    level[num_of_levels]
  }
 </pre>
</blockquote>
  The LOD node selects the appropriate node from the nodes enumerated in "level" corresponding to the present distance between the global_translation and the camera.  The LOD node is not evaluated until evaluation of the active camera is finished.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Marker">
<h3>Marker</h3>
<blockquote>
 <pre>
  Marker 'MRKR' {
    long  name_entry
    short type
    short group_index
  }
 </pre>
</blockquote>
  This node is used for displaying the coordinate icons.  The red coordinate icon corresponds to the X axis, the green to the Y axis, and the blue to the Z axis.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Material">
<h3>Material</h3>
<blockquote>
 <pre>

  Material 'MTRL' {
    long    name_entry
    node    light_set
    float4  ambient              :0
            # Value from 0 ~ 255.
    float4  emission             :1
            # Value from 0 ~ 255.
    float4  diffuse              :2
            # Value from 0 ~ 255.
    float4  primitive_color      :3
            # Value from 0 ~ 255.
    float4  primitive_color_fog  :4
            # Value from 0 ~ 255.
    char    lighting
            # 0: No lighting.
            # 1: With lighting.
    char    shade_model
            # 0: flat
            # 1: smooth
    char    effect
            # 0: none
            # 1: specular
            # 2: reflection
    char    env_color_mode
            # &1: emission
            # &2: ambient
            # Specifies which components to add to env_color.  The components added to 
            # env_color are not added to shade_color.
    {
      char4   CC0color
              # In order of A, B, C,D.
              #  0: CombColor
              #  1: Tex0Color
              #  2: Tex1Color
              #  3: PrimColor
              #  4: ShadeColor
              #  5: EnvColor
              #  6: KeyCenter(B only),KeyScale(C only),1.0(A,D only)
              #  7: CombAlpha(C only),Noise(A only),K4(B only),0.0(D only)
              #  8: Tex0Alpha(C only)
              #  9: Tex1Alpha(C only)
              # 10: PrimAlpha(C only)
              # 11: ShadeAlpha(C only)
              # 12: EnvAlpha(C only)
              # 13: LODFrac(C only)
              # 14: PrimLODFrac(C only)
              # 15: K5(C only)
              # 31: 0.0
      char4   CC0alpha
              # In order of A, B, C, D.
              #  0: CombAlpha(A,B,D only),LODFrac(C only)
              #  1: Tex0Alpha
              #  2: Tex1Alpha
              #  3: PrimAlpha
              #  4: ShadeAlpha
              #  5: EnvAlpha
              #  6: PrimLODFrac(C only),1.0(A,B,D only)
              #  7: 0.0
      char4   CC1color
              # The same as CC0color.
      char4   CC1alpha
              # The same as CC0alpha.
    } cc_mode[2]
  }
 </pre>
</blockquote>
Defines the material.  The material mechanism has been changed significantly since NIFF1.0.  In NIFF1.0, shade was monochrome, but in NIFF2.0, colors were added in consideration of ambient, emission, and diffuse.  Because of this change, the method for setting the color combiner is also different.  Shade is calculated using the following expression.   

<blockquote>
 <pre>
  shade = mat_emission + light_ambient*mat_ambient + light[0]*mat_diffuse[0]*d[0] + ....
 </pre>
</blockquote>
Here, d[I] is the "diffuse" coefficient determined from the direction of light source "I" and the normal line of the vertex.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Module">
<h3>Module</h3>
<blockquote>
 <pre>
  Module 'MDUL' {
    long    name_entry
    long    module_id
  }
 </pre>
</blockquote>
  Defines Module.  The Module behaves as if the whole Module has become a child of this node.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Nop">
<h3>Nop</h3>
<blockquote>
 <pre>
  Nop 'NOPR' {
    long    name_entry
    long    num_of_children
    node    child[num_of_children]
  }
 </pre>
</blockquote>
  Does nothing.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Orientation">
<h3>Orientation</h3>
<blockquote>
 <pre>
  Orientation 'ORNT' {
    long    name_entry
    float3  ex                  :0
    float3  ey                  :1
    long    num_of_children
    node    child[num_of_children]
  output:
    float9  global_orientation  :2
  }
 </pre>
</blockquote>
  Orientation specifies the direction of the X axis and the direction of the Y axis to create a rotation matrix.  The Y axis is corrected so that it is orthogonal to the X axis.  All children are influenced by this coordinate transformation.  In addition, ex and ey are assured to be stored in a contiguous area, and ex[3] is handled in the same manner as ey[0].  By utilizing this, it becomes possible to attach 6-element animation.  If you use 6-element animation the keyframe compression rate will probably be lower than with 3-element animation, but the tradeoff is a boost in processing speed.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="OrientationConstraint">
<h3>OrientationConstraint</h3>
<blockquote>
 <pre>
  OriConstraint 'ORIC' {
    long    name_entry
    float9  orientation         :0
    long    num_of_children
    node    child[num_of_children]
  }
 </pre>
</blockquote>
  OriConstraint specifies the rotation matrix as a global matrix.  All children are influenced by this coordinate transformation. 

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="PerspectiveCamera">
<h3>PerspectiveCamera</h3>
<blockquote>
 <pre>

  PerspectiveCamera 'PCAM' {
    long    name_entry
    float   field_of_view_y  :0
    float   aspect_ratio     :1
    float   clip_near        :2
    float   clip_far         :3
    float   tan_clip_left    :4
    float   tan_clip_right   :5
    float   tan_clip_top     :6
    float   tan_clip_bottom  :7
    long    group_mask
  }
 </pre>
</blockquote>
  Defines the camera perspective.  field_of_view_y is specified in degrees.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="PositionConstraint">
<h3>PositionConstraint</h3>
<blockquote>
 <pre>

  PositionConstraint 'POSC' {
    long    name_entry
    float3  translation      :0
    long    num_of_children
    node    child[num_of_children]
  output:
    float3  global_position  :1
  }
 </pre>
</blockquote>
  PositionConstraint specifies the translation with global vectors.  All children are influenced by this coordinate transformation. 

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="RotationXYZ">
<h3>RotationXYZ</h3>
<blockquote>
 <pre>
  RotationXYZ 'RXYZ' {
    long    name_entry
    float3  rotation            :0
            # radian value
    long    num_of_children
    node    child[num_of_children]
  output:
    float9  global_orientation  :1
  }
 </pre>
</blockquote>
  RotationXYZ rotates in order around the X, Y and Z axes.  All children are influenced by this coordinate transformation. 

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="RotationY">
<h3>RotationY</h3>
<blockquote>
 <pre>
  RotationY 'ROTY' {
    long    name_entry
    float   rotation            :0
            # radian value
    long    num_of_children
    node    child[num_of_children]
  output:
    float9  global_orientation  :1
  }
 </pre>
</blockquote>
  RotationY rotates around the Y axis.  All children are influenced by this coordinate transformation.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="RotationZXY">
<h3>RotationZXY</h3>
<blockquote>
 <pre>
  RotationZXY 'RZXY' {
    long    name_entry
    float3  rotation            :0
            # radian value
    long    num_of_children
    node    child[num_of_children]
  output:
    float9  global_orientation  :1
  }
 </pre>
</blockquote>
  RotationZXY rotates in order around the Z, X and Y axes.  All children are influenced by this coordinate transformation.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Scale">
<h3>Scale</h3>
<blockquote>
 <pre>
  Scale 'SCAL' {
    long    name_entry
    float3  scale         :0
    long    num_of_children
    node    child[num_of_children]
  output:
    float3  global_scale  :1
  }
 </pre>
</blockquote>
  Scale specifies the SOFTIMAGE format scale of enlargement.  This method of enlargement is particularly effective with character animation.  All children are influenced by this coordinate transformation.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Shape">
<h3>Shape</h3>
<blockquote>
 <pre>
  Shape 'SHAP' {
    long    name_entry
    char    group( 0 ~ 31 )
    char    cull_face( &1:front face, &2:back face )
    char    vertex_mode
            # &1: use_vertex_color
            # &2: use_vertex_alpha
    char    z_enable;
            # 0: Do not use ZBUFFER.
            # 1: Use ZBUFFER.
    char    cycle[2]( 0:fill, 1:1 cyc., 2:2 cyc. 3:copy )
    {
      char4   BL0
              # In order of P, A, M, B
              # For P, M
              #  0: InColor
              #  1: MemColor
              #  2: BlendColor
              #  3: FogColor
              # For A
              #  0: InAlpha
              #  1: FogAlpha
              #  2: ShadeAlpha
              #  3: 0.0
              # For B
              #  0: 1-A
              #  1: MemAlpha
              #  2: 1.0
              #  3: 0.0
      char4   BL1
              # The same as BL0
      short   render_mode
              # &8: AA_EN
              # &0x10: Z_CMP
              # &0x20: Z_UPD
              # &0x40: IM_RD
              # &0x80: CLR_ON_CVG
              # &0x300 = 0x000: CVG_DST_CLAMP
              # &0x300 = 0x100: CVG_DST_WRAP
              # &0x300 = 0x200: CVG_DST_FULL
              # &0x300 = 0x300: CVG_DST_SAVE
              # &0xC00 = 0x000: ZMODE_OPA
              # &0xC00 = 0x400: ZMODE_INTER
              # &0xC00 = 0x800: ZMODE_XLU
              # &0xC00 = 0xC00: ZMODE_DEC
              # &0x1000: CVG_X_ALPHA
              # &0x2000: ALPHA_CVG_SEL
              # &0x4000: FORCE_BL
    } render_mode[2]
    node    geometry
    node    material
    node    texture
  }
 </pre>
</blockquote>
Integrates geometry, material and texture, and creates the drawing object.  

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Skeleton2d2">
<h3>Skeleton2d2</h3>
<blockquote>
 <pre>
  Skeleton2D2 'SK22' {
    long    name_entry
    long    flip
    float   bone_length[2]  :0
    float3  effector_pos    :1
    float3  axis            :2
  output:
    float9  orientation1    :3
    float3  translation1    :4
    float9  orientation2    :5
    float3  translation2    :6
  }
 </pre>
</blockquote>
  Defines Skeleton.  Skeleton is the node used for processing inverse kinematics.  "axis" is a vector indicating the extent to which the Z axis differs from its original direction.  The inverse kinematics algorithm is omitted here.  

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="SkeletonPx2">
<h3>SkeletonPx2</h3>
<blockquote>
 <pre>
  SkeletonPX2 'SKP2' {
    long    name_entry
    long    flip
    float   bone_length[2]  :0
    float3  effector_pos    :1
    float3  z_pos           :2
    float3  axis            :3
  output:
    float9  orientation1    :4
    float3  translation1    :5
    float9  orientation2    :6
    float3  translation2    :7
  }
 </pre>
</blockquote>
  Defines Skeleton.  Skeleton is the node used for processing inverse kinematics.  "axis" is a vector indicating the extent to which the Z axis differs from its original direction.  The difference between SkeletonPx2 and <a href="#Skeleton2d2">Skeleton2d2</a> is that SkeletonPx2 can specify the Z axis direction by using z_pos.  The inverse kinematics algorithm is omitted here.  

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="SkeletonUv2">
<h3>SkeletonUv2</h3>
<blockquote>
 <pre>
  SkeletonUV2 'SKU2' {
    long    name_entry
    long    flip
    float   bone_length[2]  :0
    float3  effector_pos    :1
    float3  resplane_pos    :2
    float3  axis            :3
  output:
    float9  orientation1    :4
    float3  translation1    :5
    float9  orientation2    :6
    float3  translation2    :7
  }
 </pre>
</blockquote>
    Defines Skeleton.  Skeleton is the node used for processing inverse kinematics.  "axis" is a vector indicating the extent to which the Z axis differs from its original direction.  The difference between SkeletonUv2 and <a href="#Skeleton2d2">Skeleton2d2</a> is that SkeletonUv2 can specify the Y axis direction by using resplane_pos.  The inverse kinematics  algorithm is omitted here.  

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Switch">
<h3>Switch</h3>
<blockquote>
 <pre>
  Switch 'SWCH' {
    long    name_entry
    long    num_of_choice
    long    which_choice  :0
    node    choice[num_of_choice]
  }
 </pre>
</blockquote>
  Switch selects the node specified by which_choice.  When which_choice is 0xFFFFFFFF, no "choice" is selected.  

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Texture">
<h3>Texture</h3>
<blockquote>
 <pre>
  Texture 'TXTR' {
    long    name_entry
    node    image
    node    lut
    short   scaling_s
    short   scaling_t
    char    mipmap
            # 0: Do not use MipMap.
            # 1: Use MipMap.
    char    texture_detail
            # 0: clamp
            # 1: sharp
            # 2: detail
    char    filter
            # 0: nearest
            # 1: bilinear
            # 2: average
    char    perspective_correction
            # 0: No perspective correction.
            # 1: Perspective correction.
    char    yuv_color_convert
            # 0: Do not use YUV color conversion.
            # 1: Use YUV color conversion.
    char    num_of_tiles
	    # The maximum is 7 tiles.  (For the sake of "run time" optimization.)
    {
      long    texel_offset
      char    format
              # 0: I4
              # 1: I8
              # 2: IA31
              # 3: IA44
              # 4: IA88
              # 5: RGBA5551
              # 6: RGBA8888
              # 7: YUV
              # 8: CI4
              # 9: CI8
      char    lut_offset
              # The actual LUT offset is the sum of the Texture's lut_offset
              # and the tile's lut_offset.
      short   stride
              # The width of the tile in "word" units 
      short   s0
      short   t0
      short   s1
      short   t1
      char    clamp_mode_s
              # &1: mirror
              # &2: clamp
      char    clamp_mode_t
              # The same as clamp_mode_s.
      char    shift_s
      char    shift_t
      char    mask_s
      char    mask_t
    } tile[num_of_tiles]
  }
 </pre>
</blockquote>
  Defines the Texture.  The image and the color table are not defined in the Texture node.  What mainly is defined is tile-related information.  

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="TextureImage">
<h3>TextureImage</h3>
<blockquote>
 <pre>
  TextureImage 'TXIM' {
    long    name_entry
    long    segment
    long    texel_size
    char8   texel[texel_size]
  }
 </pre>
</blockquote>
  Defines the texture image.  

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="TextureLut">
<h3>TextureLut</h3>
<blockquote>
 <pre>
  TextureLUT 'TLUT' {
    long    name_entry
    char    segment
    char    format
            # 0:RGBA5551
            # 1:IA88
    short   lut_size
    short   lut[lut_size]
  }
 </pre>
</blockquote>
  Defines the texture color table. 

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="TransformInfo">
<h3>TransformInfo</h3>
<blockquote>
 <pre>
  TransformInfo 'XFMI' {
    long    name_entry
  output:
    float3  global_scale        :0
    float3  global_cls_scale    :1
    float3  global_position     :2
    float9  global_orientation  :3
  }
 </pre>
</blockquote>
  This does nothing, but it is used when referencing the coordinate transformation information.  

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="Translation">
<h3>Translation</h3>
<blockquote>
 <pre>
  Translation 'XLAT' {
    long    name_entry
    float3  translation      :0
    long    num_of_children
    node    child[num_of_children]
  output:
    float3  global_position  :1
  }
 </pre>
</blockquote>
  Translation specifies the translation.  All children are influenced by this coordinate transformation.  

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="VertexInterpolator">
<h3>VertexInterpolator</h3>
<blockquote>
 <pre>
  VertexInterpolator 'VTXI' {
    long    name_entry
    long    segment
	    # The segment number of the vertex storage buffer.
    short   num_of_vertices

    # The following is the coordinate information
    short   coord_interpolation_type;
            # 0: constant
            # 1: linear
    short   num_of_coord_tables
            # When num_of_coord_tables is set to 1, the coord component is not interpolated.
    short   num_of_coords
    {
      float   key
      short3  coord[num_of_coords]
    } coord_table[num_of_coord_tables]

    # The following is the normal line information
    short   normal_interpolation_type;
            # 0: constant
            # 1: linear
    short   num_of_normal_tables
            # When num_of_normal_tables is set to 1, 
            # the normal component is not interpolated.  
    short   num_of_normals
    {
      float   key
      char4  normal[num_of_normals]
    } normal_table[num_of_normal_tables]

    # The following is the texture coordinate information
    short   tex_coord_interpolation_type;
            # 0: constant
            # 1: linear
    short   num_of_tex_coord_tables
            # When num_of_tex_coord_tables is set to 1, 
            # the tex_coord component is not interpolated.
    short   num_of_tex_coords
    {
      float   key
      short2  tex_coord[num_of_tex_coords]
    } tex_coord_table[num_of_tex_coord_tables]

    # The following information is for vertex set-up
    {
      short   coord_index
      short   normal_index
      short   tex_coord_index
    } index[num_of_vertices]

    # The following information is for triangle set-up
    long    num_of_vertex_groups
    {
      short   vertex_offset
      char    vertex_cache_offset
      char    vertex_load_count
      long    num_of_modification_group
      {
        char    num_of_rgba_modification
        char    num_of_st_modification
        char    num_of_xy_modification
        char    num_of_z_modification
        long    num_of_triangles
        {
          char    vertex_index
          char4   rgba
        } rgba_modification[num_of_rgba_modification]
        {
          char    vertex_index
          short2  st
        } st_modification[num_of_st_modification]
        {
          char    vertex_index
          short2  xy
        } xy_modification[num_of_xy_modification]
        {
          char    vertex_index
          long    z
        } z_modification[num_of_z_modification]
        char3   triangle[num_of_triangle]
      } modification_group[num_of_modifi_group]
    } vertex_group[num_of_vertex_groups]
  }
 </pre>
</blockquote>
  Defines the interpolation vertices.  These are used in AnimatedGeometry.

<p align="right">
 <a href="#noderef">Node Reference
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<a name="limitation">
<h3>
Problems / Limitations
</h3>
<h4>Material Compatibility</h4>
<ul>
 <li>EnvColor/TriColor<br>
  EnvColor and TriColor are handled differently in <a href="../nvfview/seg1.htm">nvfview</a> than they are in <a href="../n64prev/seg1.htm">n64prev</a>.  In <a href="../nvfview/seg1.htm">nvfview</a>, ambient and emission may be used for EnvColor, and TriColor is not used.  In addition, NVF has parameters that cannot be specified by NIFF1.0, but they are interpreted as follows by <a href="../niff2nvf/index.htm">niff2nvf</a>. 
  <p>
  <table border="0">
   <tr>
    <td width="40%">ambient</td><td align="right">255</td><td align="right">255</td>
    <td align="right">255</td><td align="right">255</td>
   </tr>
   <tr>
    <td>diffuse</td><td align="right">255</td><td align="right">255</td>
    <td align="right">255</td><td align="right">255</td>
   </tr>
   <tr>
    <td>emission</td><td align="right">255</td><td align="right">255</td>
    <td align="right">255</td><td align="right">255</td>
   </tr>
   <tr>
    <td>env_color_mode</td>
    <td align="left" colspan="4">emission is output to env_color</td>
   </tr>
  </table>
  <p>
  In other words, TriColor is always white.
  <p>
 <li>Color Combiner<br>
  Since all shading results are stored in ShadeColor/VtxColor with NIFF2.0 material, there is no longer any need to use PrimitiveColor.
</ul>

<h4>Large textures</h4>
In NVF, textures which exceed 4KB cannot be used.  Such large textures are split by converters like <a href="../niff2nvf/index.htm">niff2nvf</a>.  

<h4>Increased number of nodes</h4>
NVF displays a scene by taking nodes with very small functions and combining them together.  Therefore, a scene which is simply converted from NIFF to NVF has many meaningless nodes.  This increase in the number of nodes leads to an increase in processing time by the viewer's CPU and lowers the viewer's frame rate.  

<h4>The applicable range of ClassicScale</h4>
Most Skeletons and Constraints are not influenced by ClassicScale.  Rather, these nodes are influenced by Scale.  

<p align="right">
 <a href="index.htm">Index
  <img src="../../gif/index.gif" border="0" width="65" height="17">
 </a>
</p>
<hr>

<!--------------------------------------------------------------------->
<font size=-1>
Copyright 1998-1999 NINTENDO Co.,Ltd./MONEGI CORPORATION All rights reserved.
</font>

</body>
</html>
